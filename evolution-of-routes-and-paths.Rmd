---
title: The evolution of routes and paths in a dynamic environment
author:
  - name: Nicolas Gauthier
    email: Nicolas.Gauthier@asu.edu
    affiliation: Arizona State University
    footnote: Corresponding Author
address:
  - code: Arizona State University
    address: School of Human Evolution and Social Change, S. Caddy Mall, Tempe, AZ, Zip
abstract:

journal: "Journal of Archaeological Science"
date: "`r Sys.Date()`"
bibliography: mybibfile.bib
output: rticles::elsevier_article
---


```{r echo = FALSE, eval = FALSE}
# Install necessary packages if not already available (not run by default)
install.packages(c('tidyverse', 'raster', 'NLMR', 'tidygraph', 'gifski', 'png', 'gdistance', 'furrr'))

# install the dev versions of these packages from github using devtools
install.packages('devtools')
devtools::install_github('thomasp85/ggraph')
devtools::install_github('thomasp85/gganimate')
devtools::install_github('thomasp85/patchwork')
devtools::install_github('ecohealthalliance/yenpathy')
```

```{r, echo = FALSE}
library(raster)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(sf)
library(NLMR)
library(gganimate)
library(patchwork)
library(yenpathy)
library(gdistance)
```


# Introduction

Paths are physical as well as social infrastructure. Hence the dynamics.


Archaeology is embracing the form of constrained spatial interaction modeling developed by Wilson. These Boltzmann-Lotka-Volterra (BLV) style models use maximum entropy spatial interaction models to allocate flows between a spatially structured metapopulation, and Lotka-Volterra style consumer-resource equations to govern the growth of the populations. These equations are able to capture the dynamic feedbacks between settlements and the networks connecting them. Recent work in archaeology has expanded these models to allow the networks to further evolve, as routes that are more often used to connect important sites become themselves important, which in turn shapes the growth of settlements close to those routes. Past work has shown how stable routes and sets of routes can develop in mountainous topography, where physical constraints on movement are able to constrain the possible routes between settlements. 
  
Here, I extend this approach to examine how routes and paths -- the spatial networks that connect settlements -- evolve in response to patterns of environmental variability. Rather than leaving the carrying capacity of our population of settlements to remain fixed, we allow it to vary over space and in time. We examine how different patterns of spatio-temporal change lead to different settlement patterns and spatial network. We use a simple computatational modeling approach to facilitate a broad range of exploration, while maintaining interpretive clarity. We expect that different patterns, such as fixed oscillations, to lead to different stable patterns of spatial networks, whose dynamical behavior feeds back to influence settlement dynamics. In this way we seek to model the potential for "inertia" in settlement patterns, complicating the relationship between environmental forcing and social dynamics. Finally we allow for bidirectional feedbacks between human populations and the environment, exploring the potential for nonlinear social-ecological dynamics.

We distinguish here between "routes" and "paths". The former is a social construct, the latter are physical.



  Sharing and exchange are critical for maintaining population in response to interannual climate variability, although this short term stability can come at the cost of long term environmental degradation \parencite{Janssen2010}. More restricted sharing rules can be effective \parencite{Hegmon1996}, but can also be sensitive to the asymmetric accrual of debts if one party's food supply is more volatile than anothers' \parencite{Crabtree2015}.
 
Social infrastructure interacts directly with physical infrastructure because social networks must map onto spatial networks. Metabolic costs, such as the energy expended producing and transporting food over space where transportation infrastructure is sparse, provide constraints on energy flows in exchange systems \parencite{Drennan1984}. In any particular case, the balance between these costs and the metabolic benefits of social interaction influences whether resources are moved in bulk to populations in need, or whether those populations move themselves to the available resources. The topology of spatial networks also constrains who can interact with whom, introducing bottlenecks and other structural flow constraints \parencite{Barthelemy2011SpatialNetworks}. Improvements to transportation infrastructure, such as roads and trails, decrease the effective distance between different settlements; failure to maintain these transportation networks increases the effective distance \parencite{McCall1985TheAfrica}.

Regional scale patterns of spatial interaction arise from the decisions of heterogeneous agents interacting with imperfect and incomplete information. They make decisions based on the perceived costs and benefits of interaction, as far as they are able to distinguish them. It is crucial to estimate distribution of each person's subjective predictions about the costs and benefits of social interaction, conditional on the information available to them about each potential destination.

# Methods

We start with two basic entities, settlements and their hinterlands. Together these make up a simple consumer-resource system, with a population of humans in the settlement consuming agricultural resources from the hinterland. For simplicity, we assume the hinterland produces a fixed amount of food each year, varying only due to exogenous environmental factors (rainfall). The population in a settlement grows logistically, with a carrying capacity defined by the resources in its hinterland.

```{r}
logistic_growth <- function(x, k, r = 0.015){
  x * (1 + r * (1 - (x / k)))
}
```

```{r, echo = FALSE}
accumulate(rep(150, 500), logistic_growth, .init = 15) %>%
  tibble(time = 0:500, population = .) %>%
  ggplot(aes(time, population)) +
  geom_line(size = 1.2) +
  geom_hline(yintercept = 150, color = 'red', linetype = 2) +
  ggtitle('Settlement population over 500 years', 'Carrying capacity in red') +
  theme_classic()
```

A settlement is not limited to extracting food from its immediate hinterland, but rather can draw on resources from multiple hinterlands at greater distances. The amount of resources harvested from each hinterland is a function of the distance from the settlement to that hinterland. If distance played no role, we could simply add together all the discrete hinterland objects into an aggregate hinterland and recalculate the carrying capacity. Adding in this distance effect reduces this, limiting the areal extent of resource extraction from a site.
well maybe

The population of a settlement is free to move between other settlements. 


Parameters for the model.

```{r}
pop_start <- 200 # starting population per settlement
alpha <- 1.05 # superlinear returns to population size
beta <- 0.15 # distance decay parameter
```


We make a population of settlements. They all start with a population of `pop_start`, and are distributed evenly over a 100 x 100 space. We define the radius of the hexagonal cell as 5, setting a limit of 5km from a settlement as that settlement's "hinterland."

```{r}
radius <- 5
hex <- c(155, 13, 55, 13, 5, 100, 55, 187, 155, 187, 205, 100, 155, 13) %>%
  matrix(nrow = 7, byrow = 2) %>%
  list %>%
  st_polygon %>% 
  st_make_grid(cellsize = radius * 2, square = FALSE) %>%
  st_sf

n <- nrow(hex)

pts <- hex %>%
  st_centroid %>%
  st_coordinates
```

Now we create the physical network of paths connecting all neighboring settlements. 
```{r}
paths <- hex %>% 
  st_is_within_distance(dist = 1) %>%
  as.matrix %>% 
  `*`(1) %>% 
  as_tbl_graph() %E>%
  filter(!edge_is_loop(), # or implement phi parameter instead
          from < to) %>%
  mutate(distance = weight * radius * 2,
         effective_distance = distance,
         traffic = 0,
         total_traffic = 0) %>%
  select(-weight) %>%
  convert(to_undirected) %N>%
  mutate(x = pts[,1],
         y = pts[,2],
         population = pop_start,
         attractiveness = 1)
```

```{r, echo = FALSE}
ggraph(paths) + 
  geom_node_point() +
  geom_edge_link(alpha = .3) +
  coord_equal() +
  theme_void()
```


## Spatial Interaction Model

```{r interact}
k <- 1
epsilon <- .5
interact <- function(net){
  net %E>%
    mutate(utility = .N()$attractiveness[to] ^ alpha * exp(-beta * effective_distance))  %N>%
    mutate(outflow = population / centrality_degree(weights = utility,
                                                    mode = 'out', loops = FALSE)) %E>%
    mutate(flow = .N()$outflow[from] * utility) %>%
    select(-utility) %N>%
    select(-outflow)
  }

grow <- function(net){
  net %N>%
    mutate(inflow = centrality_degree(weights = flow, mode = 'in', loops = FALSE),
           attractiveness = attractiveness + epsilon * (inflow - k * attractiveness),
           population = n * pop_start * attractiveness / sum(attractiveness)) %>%
    select(-inflow)
}

# k convert units of flow to units of attractiveness. should be 1? we're interpreting units of flow as people, so probably not.... maybe we can say that a 1 of the climate variable is the amount of rain to produce enough food to feed xx people, and rescale from there?
```

```{r}
get_distance <- function(net){
  node_data <- net %N>%
    as_tibble
  
  dist_weights <- net %E>%
    as_tibble %>%
    pull(effective_distance)
  
  net %>%
    igraph::distances(weights = dist_weights) %>% # needs weight column
    as_tbl_graph(directed = TRUE) %>%
    mutate(!!!node_data) %E>%
    rename(effective_distance = weight)
}
```

```{r}
plan(multisession)



run_sim <- function(net){
  tmp <- net %>%
  get_distance %>%
  interact %>%
  grow
  
  maintain(tmp, net)
}
```

```{r}
get_paths <- function(from, net){
    
  dist_weights <- paths %E>%
    as_tibble %>%
    pull(effective_distance)
  
  shortest_paths(net, from, weights = dist_weights, output = 'epath') %>%
    .$epath %>% 
    map(as.numeric)
}


```


```{r}
improve_path <- function(traffic, a = 0.5, b = 0.0005){
  (1 - a) * exp(-b * traffic) + a
}

a <- .5
b <- .0005

plot(1:10000, improve_path(1:10000, b  = b))
```




```{r}
maintain <- function(routes, paths){
  pop <- as_tibble(routes, 'nodes') %>% pull(population)
  act <- as_tibble(routes, 'nodes') %>% pull(attractiveness)

  tmp1 <- as_tibble(routes, 'edges') %>%
    group_by(from) %>%
      nest %>%
    mutate(path = map(from, get_paths, net = paths)) %>%
    select(from, path) %>%
    unnest(cols = c(path)) %>%
    mutate(to = rep(1:n, times = n)) %>% 
    left_join(as_tibble(routes, 'edges'), .) %>%
    mutate(len = map_dbl(path, length))
  
  tmp2 <- tibble(path =  unlist(tmp1$path),
           flow = rep(tmp1$flow, times = tmp1$len)) %>%
        group_by(path) %>%
        summarise(traffic = sum(flow))

  paths %E>%
    select(-traffic) %>%
    left_join(tmp2, by = c('.tidygraph_edge_index' = 'path')) %>%
    mutate(total_traffic = traffic + total_traffic,
           effective_distance = distance * improve_path(total_traffic)) %N>%
    mutate(population = pop,
           attractiveness = act)
}
```

```{r}
paths %>%
  select(-traffic) %>%
  left_join(test2, by = c('.tidygraph_edge_index' = 'test')) %>%
  arrange(traffic) %>%
  ggraph() + geom_edge_link(aes(color = log(traffic)), width = 1.2) + theme_void() + coord_equal() + scale_edge_color_viridis()
```


```{r}
nystuen_dacey <- function(net){
  net %E>%
  group_by(from) %>%
  filter(flow == max(flow)) %>%
  ungroup %>%
  filter(.N()$population[from] < .N()$population[to]) %N>%
  mutate(terminal = node_is_sink()) %>%
  convert(to_undirected) 
}

# try using node_is_ functions to calculate instead
```

## Landscape Model

We simulate different spatial patterns of environmental variability using the `NLMR` package.

```{r}
null <- matrix(0, nrow = 210, ncol = 210) %>% 
  raster(xmx = 210, ymx = 210)
uniform <- matrix(1, nrow = 210, ncol = 210) %>% 
  raster(xmx = 210, ymx = 210)
#random <- nlm_random(210, 210)
distance_gradient <- 1- nlm_distancegradient(210, 210, origin = c(0, 10, 0, 10))
distance_gradient_center <- 1- nlm_distancegradient(210, 210, origin = c(105, 105, 105, 105))
oscillation <- distance_gradient * -1 + 1 - nlm_distancegradient(210, 210, origin = c(200, 210, 200, 210))
edge_gradient <- nlm_edgegradient(210, 210, direction = 0)
planar_gradient <- nlm_planargradient(210, 210, direction = 0)

grf_001 <- nlm_gaussianfield(210, 210, autocorr_range = 1, user_seed = 1000)
grf_010 <- nlm_gaussianfield(210, 210, autocorr_range = 10, user_seed = 1000)
grf_100 <- nlm_gaussianfield(210, 210, autocorr_range = 100, user_seed = 1000)
```


```{r}
env_names <- c('null', 'uniform', 'random', 'distance_gradient_center', 'edge_gradient', 'oscillation', 'grf_001', 'grf_010', 'grf_100')
env <- brick(null, uniform, random, distance_gradient_center, edge_gradient, oscillation, grf_001, grf_010, grf_100) %>%
  `names<-`(env_names) %>%
  raster::extract(hex, fun = mean, na.rm = TRUE, df = TRUE) %>%
  bind_cols(hex, .)
```

```{r echo = FALSE}
env %>%
  gather(variable, value, null:grf_100) %>%
  mutate(variable = fct_relevel(variable, env_names)) %>%
  filter(!(variable %in% c('null', 'uniform', 'random'))) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  facet_wrap(~variable) +
  theme_void() +
  scale_fill_viridis_c() +
  coord_sf(datum = NA)
```

```{r}
library(profvis)

profvis(run_sim(paths))
```

# Results

```{r message = FALSE}
sim_length <- 50 # number of time steps

sim <- accumulate(1:sim_length, ~run_sim(.x), .init = paths) %>%
  .[2:sim_length]# remove the initial state
```


```{r, echo = FALSE}
sim %>%
   # map(nystuen_dacey) %>%
  map(activate, 'nodes') %>%
   map(as_tibble) %>%
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
ggplot(aes(x, y, size = population)) +
  geom_point()+#aes(color = terminal)) +
  coord_equal() +
  theme_void() +
  labs(title = 'Year: {closest_state}') +
  transition_states(time)
```

```{r}
sim[[49]] %E>%
  arrange(effective_distance) %>%
 # nystuen_dacey %>%
ggraph(x = x, y = y) + 
  geom_edge_fan(aes(color = (total_traffic)), width = 1.2) +
   # geom_node_point(aes(size = population)) +#, color = terminal)) +
  #scale_color_manual(values = c('black', 'red')) +
  scale_edge_color_viridis() +
  coord_equal() +
  theme_void()


sim[[49]] %E>%
  mutate(effective_distance = -1 * (effective_distance - 10)) %>%
  arrange(effective_distance) %>%
  #filter(effective_distance < 6) %>%
 # nystuen_dacey %>%
ggraph(x = x, y = y) + 
  geom_edge_fan(aes(color = effective_distance), width = 2) +
    geom_node_point(aes(size = population)) +#, color = terminal)) +
  #scale_color_manual(values = c('black', 'red')) +
  scale_edge_color_viridis(option = 'A') +
  coord_equal() +
  theme_void()
```

Here are two sample references: @Feynman1963118 [@Dirac1953888].


# Discussion


# Conclusion


# References {#references .unnumbered}

```{r}
knitr::knit_exit()
```


Experimenting with gdistance
```{r}
env <- matrix(1, nrow = 100, ncol = 100) %>% 
  raster(xmx = 100, ymx = 100)

euc_dist <- function(x1, x2, y1, y2){
  sqrt((x1 - x2) ^ 2 + (y1 - y2) ^2)
}

trans <- transition(env, transitionFunction = mean, directions = 8) %>%
  geoCorrection(type = 'r')

set.seed(1000)
settlements <- tbl_graph(edges = expand.grid(from = 1:n, to = 1:n),
                 nodes = tibble(population = pop_start,
                                attractiveness = 1,
                                x = sample(1:100, n, replace = TRUE),
                                y = sample(1:100, n, replace = TRUE))) %E>%
  mutate(euclidean = euc_dist(.N()$x[from], .N()$x[to], 
                             .N()$y[from], .N()$y[to])) %>%
  filter(!edge_is_loop())

sites <- settlements %N>%
  as_tibble() %>%
  select(x:y) %>%
  as.matrix

accCost(trans, sites) %>% plot

routes <- commuteDistance(trans, sites) %>%
  as.matrix %>%
  as_tbl_graph %E>%
  as_tibble %>%
  left_join(settlements, .) 


routes %>%
  as_tibble() %>%
  ggplot(aes(euclidean, weight)) + geom_point()

passage(trans, sites[2,], sites[1,], theta=5) %>% plot

plan(multicore, workers = 3)

paths <- routes %E>%
  as_tibble %>%
  filter(from > to) %>%
  mutate(passage = future_map2(from, to, ~passage(trans, sites[.x, ], sites[.y,], theta = 15)))

t1 <- paths %>% pull(passage) %>% brick %>% sum
plot(t1 / 300)

1:20 %>% accumulate(~.*(log(2) + 1), .init = t1) %>% .[[20]] %>% plot

feedback <- function(x) 

paths <- settlements %E>%
  group_by(from) %>% 
  top_n(-6, distance) %>%
  ungroup %N>%
  igraph::as.undirected(mode = 'collapse', edge.attr.comb = 'first') %>%
  as_tbl_graph
```
