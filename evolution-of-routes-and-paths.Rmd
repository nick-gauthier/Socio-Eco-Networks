---
title: The evolution of routes and paths in a dynamic environment
author:
  - name: Nicolas Gauthier
    email: Nicolas.Gauthier@asu.edu
    affiliation: Arizona State University
    footnote: Corresponding Author
address:
  - code: Arizona State University
    address: School of Human Evolution and Social Change, S. Caddy Mall, Tempe, AZ, Zip
abstract:

journal: "Journal of Archaeological Science"
date: "`r Sys.Date()`"
bibliography: mybibfile.bib
output: rticles::elsevier_article
---


```{r echo = FALSE, eval = FALSE}
# Install necessary packages if not already available (not run by default)
install.packages(c('tidyverse', 'raster', 'NLMR', 'tidygraph', 'gifski', 'png', 'gdistance', 'furrr'))

# install the dev versions of these packages from github using devtools
install.packages('devtools')
devtools::install_github('thomasp85/ggraph')
devtools::install_github('thomasp85/gganimate')
devtools::install_github('thomasp85/patchwork')
devtools::install_github('ecohealthalliance/yenpathy')
```

```{r, echo = FALSE}
library(raster)
library(tidyverse)
library(tidygraph)
library(ggraph)
library(sf)
library(NLMR)
library(gganimate)
library(patchwork)
library(yenpathy)
library(gdistance)
library(furrr)
```


# Introduction

Paths are physical as well as social infrastructure. Hence the dynamics.


Archaeology is embracing the form of constrained spatial interaction modeling developed by Wilson. These Boltzmann-Lotka-Volterra (BLV) style models use maximum entropy spatial interaction models to allocate flows between a spatially structured metapopulation, and Lotka-Volterra style consumer-resource equations to govern the growth of the populations. These equations are able to capture the dynamic feedbacks between settlements and the networks connecting them. Recent work in archaeology has expanded these models to allow the networks to further evolve, as routes that are more often used to connect important sites become themselves important, which in turn shapes the growth of settlements close to those routes. Past work has shown how stable routes and sets of routes can develop in mountainous topography, where physical constraints on movement are able to constrain the possible routes between settlements. 
  
Here, I extend this approach to examine how routes and paths -- the spatial networks that connect settlements -- evolve in response to patterns of environmental variability. Rather than leaving the carrying capacity of our population of settlements to remain fixed, we allow it to vary over space and in time. We examine how different patterns of spatio-temporal change lead to different settlement patterns and spatial network. We use a simple computatational modeling approach to facilitate a broad range of exploration, while maintaining interpretive clarity. We expect that different patterns, such as fixed oscillations, to lead to different stable patterns of spatial networks, whose dynamical behavior feeds back to influence settlement dynamics. In this way we seek to model the potential for "inertia" in settlement patterns, complicating the relationship between environmental forcing and social dynamics. Finally we allow for bidirectional feedbacks between human populations and the environment, exploring the potential for nonlinear social-ecological dynamics.

We distinguish here between "routes" and "paths". The former is a social construct, the latter are physical.



  Sharing and exchange are critical for maintaining population in response to interannual climate variability, although this short term stability can come at the cost of long term environmental degradation \parencite{Janssen2010}. More restricted sharing rules can be effective \parencite{Hegmon1996}, but can also be sensitive to the asymmetric accrual of debts if one party's food supply is more volatile than anothers' \parencite{Crabtree2015}.
 
Social infrastructure interacts directly with physical infrastructure because social networks must map onto spatial networks. Metabolic costs, such as the energy expended producing and transporting food over space where transportation infrastructure is sparse, provide constraints on energy flows in exchange systems \parencite{Drennan1984}. In any particular case, the balance between these costs and the metabolic benefits of social interaction influences whether resources are moved in bulk to populations in need, or whether those populations move themselves to the available resources. The topology of spatial networks also constrains who can interact with whom, introducing bottlenecks and other structural flow constraints \parencite{Barthelemy2011SpatialNetworks}. Improvements to transportation infrastructure, such as roads and trails, decrease the effective distance between different settlements; failure to maintain these transportation networks increases the effective distance \parencite{McCall1985TheAfrica}.

Regional scale patterns of spatial interaction arise from the decisions of heterogeneous agents interacting with imperfect and incomplete information. They make decisions based on the perceived costs and benefits of interaction, as far as they are able to distinguish them. It is crucial to estimate distribution of each person's subjective predictions about the costs and benefits of social interaction, conditional on the information available to them about each potential destination.

Self organization ... settlemetn patterns represent spontaneous order in response to spatial variability. positive feedbacks

cite crema 2015 for vraying caryying capcity

# Methods

We start with two basic entities, settlements and their hinterlands. Together these make up a simple consumer-resource system, with a population of humans in the settlement consuming agricultural resources from the hinterland. For simplicity, we assume the hinterland produces a fixed amount of food each year, varying only due to exogenous environmental factors (rainfall). The population in a settlement grows logistically, with a carrying capacity defined by the resources in its hinterland.

```{r}
logistic_growth <- function(x, k, r = 0.015){
  x * (1 + r * (1 - (x / k)))
}
```

```{r, echo = FALSE}
accumulate(rep(150, 500), logistic_growth, .init = 15) %>%
  tibble(time = 0:500, population = .) %>%
  ggplot(aes(time, population)) +
  geom_line(size = 1.2) +
  geom_hline(yintercept = 150, color = 'red', linetype = 2) +
  ggtitle('Settlement population over 500 years', 'Carrying capacity in red') +
  theme_classic()
```

A settlement is not limited to extracting food from its immediate hinterland, but rather can draw on resources from multiple hinterlands at greater distances. The amount of resources harvested from each hinterland is a function of the distance from the settlement to that hinterland. If distance played no role, we could simply add together all the discrete hinterland objects into an aggregate hinterland and recalculate the carrying capacity. Adding in this distance effect reduces this, limiting the areal extent of resource extraction from a site.
well maybe

The population of a settlement is free to move between other settlements. 


Parameters for the model.

```{r}
pop_start <- 200 # starting population per settlement
#alpha <- 1.05#1.05 # superlinear returns to population size
#beta <- 0.15 # distance decay parameter
```


We make a population of settlements. They all start with a population of `pop_start`, and are distributed evenly over a 100 x 100 space. We define the radius of the hexagonal cell as 5, setting a limit of 5km from a settlement as that settlement's "hinterland."

Why hexagons (birch et al 2007). Edge effects of the whole hexagonal domainare slo decreased
```{r}
radius <- 5

hex <- c(155, 13, 55, 13, 5, 100, 55, 187, 155, 187, 205, 100, 155, 13) %>%
  matrix(nrow = 7, byrow = 2) %>%
  list %>%
  st_polygon %>% 
  st_make_grid(cellsize = radius * 2, square = FALSE) %>%
  st_sf

n <- nrow(hex)

pts <- hex %>%
  st_centroid %>%
  st_coordinates

tst <- pts
tst[,2] <- tst[,2] + max(pts[,2]) - min(pts[,2]) * .5
tst[,1] <- tst[,1] + min(pts[,1])
plot(rbind(pts, tst))

min(pts[,1])
max(pts[,2])
```

Now we create the physical network of paths connecting all neighboring settlements. 
```{r}
paths <- hex %>% 
  st_is_within_distance(dist = 1) %>%
  as.matrix %>% 
  `*`(1) %>% 
  as_tbl_graph() %E>%
  filter( from <= to) %>%#!edge_is_loop(), # or implement phi parameter instead
  mutate(distance = if_else(edge_is_loop(), 0, weight * radius * 2),
         effective_distance = distance,
         traffic = 0,
         total_traffic = 0) %>%
  select(-weight) %>%
  convert(to_undirected) %N>%
  mutate(x = pts[,1],
         y = pts[,2],
         food = 200,
         population = pop_start,
         attractiveness = 1, 
         edge = centrality_degree() < 6)
```

```{r, echo = FALSE}
ggraph(paths) + 
  geom_edge_link(alpha = .3) +
    geom_node_point() +
  coord_equal() +
  theme_void()
```


## Landscape Model

We simulate different spatial patterns of environmental variability using the `NLMR` package.

```{r}
null <- matrix(0, nrow = 210, ncol = 210) %>% 
  raster(xmx = 210, ymx = 210)
uniform <- matrix(1, nrow = 210, ncol = 210) %>% 
  raster(xmx = 210, ymx = 210)
#random <- nlm_random(210, 210)
distance_gradient <- 1- nlm_distancegradient(210, 210, origin = c(0, 10, 0, 10))
distance_gradient_center <- 1- nlm_distancegradient(210, 210, origin = c(105, 105, 105, 105))
oscillation <- distance_gradient * -1 + 1 - nlm_distancegradient(210, 210, origin = c(200, 210, 200, 210))
edge_gradient <- nlm_edgegradient(210, 210, direction = 0)
planar_gradient <- nlm_planargradient(210, 210, direction = 0)

grf_001 <- nlm_gaussianfield(210, 210, autocorr_range = 1, user_seed = 1000)
grf_010 <- nlm_gaussianfield(210, 210, autocorr_range = 10, user_seed = 1000)
grf_100 <- nlm_gaussianfield(210, 210, autocorr_range = 100, user_seed = 1000)
```


```{r}
env_names <- c('null', 'uniform','distance_gradient_center', 'edge_gradient', 'oscillation', 'grf_001', 'grf_010', 'grf_100')
env <- brick(null, uniform, distance_gradient_center, edge_gradient, oscillation, grf_001, grf_010, grf_100) %>%
  `names<-`(env_names) %>%
  raster::extract(hex, fun = mean, na.rm = TRUE, df = TRUE) %>%
  bind_cols(hex, .)
```

```{r echo = FALSE}
env %>%
  gather(variable, value, null:grf_100) %>%
  mutate(variable = fct_relevel(variable, env_names)) %>%
  filter(!(variable %in% c('null', 'uniform', 'random'))) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  facet_wrap(~variable) +
  theme_void() +
  scale_fill_viridis_c() +
  coord_sf(datum = NA)
```

## Spatial Interaction Model

```{r interact}
interact <- function(net, alpha = 1.05, beta = 0.2){
  net %E>%
    mutate(utility = .N()$attractiveness[to] ^ alpha * exp(-beta * effective_distance))  %N>%
    mutate(outflow = population / centrality_degree(weights = utility,
                                                    mode = 'out', loops = FALSE)) %E>%
    mutate(flow = .N()$outflow[from] * utility) %>%
    select(-utility) %N>%
    select(-outflow)
  }

grow <- function(net, k = 1, epsilon = 0.1, G = 0.1){
  net %N>%
    mutate(inflow = centrality_degree(weights = flow, mode = 'in', loops = FALSE),
           inflow = if_else(edge == TRUE, inflow + inflow * G, inflow),
           attractiveness = attractiveness + epsilon * (inflow - k * attractiveness),
           population = n * pop_start * attractiveness / sum(attractiveness)) %>%
    select(-inflow)
}

# k convert units of flow to units of attractiveness. should be 1? we're interpreting units of flow as people, so probably not.... maybe we can say that a 1 of the climate variable is the amount of rain to produce enough food to feed xx people, and rescale from there?
```

```{r}
get_distance <- function(net){
  node_data <- as_tibble(net, 'nodes')
  
  dist_weights <- as_tibble(net, 'edges')$effective_distance
  
  net %>%
    igraph::distances(weights = dist_weights) %>% # needs weight column
    replace(. == 0, 999) %>% # replace 0 values with 999 temporarily
    as_tbl_graph(directed = TRUE) %>%
    mutate(!!!node_data) %E>%
    mutate(weight = if_else(weight == 999, 0, weight)) %>%
    rename(effective_distance = weight)
}
```



```{r}
maintain <- function(routes, paths, a, b){
  pop <- as_tibble(routes, 'nodes') %>% pull(population)
  act <- as_tibble(routes, 'nodes') %>% pull(attractiveness)

  tmp1 <- as_tibble(routes, 'edges') %>%
    group_by(from) %>%
      nest %>%
    mutate(path = map(from, get_paths, net = paths)) %>%
    select(from, path) %>%
    unnest(cols = c(path)) %>%
    mutate(to = rep(1:n, times = n)) %>% 
    left_join(as_tibble(routes, 'edges'), .) %>%
    mutate(len = map_dbl(path, length))
  
  tmp2 <- tibble(path =  unlist(tmp1$path),
           flow = rep(tmp1$flow, times = tmp1$len)) %>%
        group_by(path) %>%
        summarise(traffic = sum(flow))

  paths %E>%
    select(-traffic) %>%
    left_join(tmp2, by = c('.tidygraph_edge_index' = 'path')) %>%
    mutate(total_traffic = traffic + total_traffic,
           effective_distance = distance * improve_path(total_traffic, a = a, b = b)) %N>%
    mutate(population = pop,
           attractiveness = act)
}

get_paths <- function(from, net){
    
  dist_weights <- paths %E>%
    as_tibble %>%
    pull(effective_distance)
  
  shortest_paths(net, from, weights = dist_weights, output = 'epath') %>%
    .$epath %>% 
    map(as.numeric)
}

improve_path <- function(traffic, a, b){
  (1 - a) * exp(-b * traffic) + a
}
```

So instead of just this have a two sector model. flow of food from hinterland to centers ... this effects their carrying capacity. then flow of people between centers based on carryin capacity and size ... this is the qubbaj et al model with spatial interaction terms. as a first line, we assume that people only draw food from their direct hinterland, so instead we are looking at the flow of people between  the settlements based on food availability.

so does this mean we can vary k or what?

or have it be inflow + local carrying capacity  - k * attractiveness?

so it seems like we want to incorporate carrying capcaity into the population dynamics, not the interaction dynamics. that is the caryring capacity doesn't enter directly into the utilityes, but rather influences the settlement sizes which in turn effects the utilities. hmmmm not sure about this

maybe this is all just to day do the welfare modulated diffuse thing?

or have attractiveness based on food ratio, but the evolution rule only changes population endogenously and caryring capacity is left exogenous

maybe the phi thing from crema 2014 and 2015, with ratio of population to carrying capacity if above carrying capcity

I think there's still room for welfare modulated diffusion here

maybe have another epsioln development thing for migrant with a migration rate like .05


OOOOOOOH trade inflow is the attractiveness term for migrant flow
```{r}
run_sim <- function(net, alpha = 1.05, beta_food = 0.45, beta_people = 0.15, nu = 0.05, k = 1, epsilon = 0.01, G = 0, a = 0.2, b = .0005){
  net %E>%
    #get_distance  %E>%
    # interact
    mutate(trade_utility = .N()$population[to] ^ alpha * exp(-beta_food * effective_distance))  %N>%
    mutate(trade_outflow = food / centrality_degree(weights = trade_utility, mode = 'out', loops = TRUE)) %E>%
    mutate(trade_flow = .N()$trade_outflow[from] * trade_utility) %N>% 
    mutate(trade_inflow = centrality_degree(weights = trade_flow, mode = 'in', loops = TRUE)) %E>%
    mutate(migrant_utility = .N()$trade_inflow[to] * .N()$population[to] ^ (alpha - 1) * exp(-beta_people * effective_distance)) %N>%
    mutate(migrant_outflow = nu * population / centrality_degree(weights = migrant_utility, mode = 'out', loops = TRUE)) %E>%
    mutate(migrant_flow = .N()$migrant_outflow[from] * migrant_utility) %N>%        
    mutate(migrant_inflow = centrality_degree(weights = migrant_flow, mode = 'in', loops = TRUE),
           #inflow = if_else(edge == TRUE, inflow + inflow * G, inflow),
           population = population + epsilon * (trade_inflow - k * population) - 0.05 * population + migrant_inflow) # %>%
           #attractiveness = attractiveness + epsilon * (inflow - k * attractiveness),
           #population = n * pop_start * population / sum(population)) %>%
    # select(-inflow)
  
  #maintain(tmp, net, a, b)
}
```
```{r}
(97.5 - 200) * .01
```

```{r}
nystuen_dacey <- function(net){
  net %E>%
  group_by(from) %>%
  filter(flow == max(flow)) %>%
  ungroup %>%
  filter(.N()$population[from] < .N()$population[to]) %N>%
  mutate(terminal = node_is_sink()) %>%
  convert(to_undirected) 
}

# try using node_is_ functions to calculate instead
```

```{r}
library(profvis)

profvis(run_sim(paths))
```


# Results

Maybe try running with all environmentalattreativeness and no population feedback, but instead with the growing roads?

or disaggregate so to attractivenesses are carrying capacity and size relative to carrying capacity?

```{r message = FALSE}
sim_length <- 200 # number of time steps

sim <- accumulate(1:sim_length, ~run_sim(.x), .init = paths %>% get_distance) %>%
  .[2:sim_length]# remove the initial state
```

```{r}
qplot(seq(.1, 10, by = .1),2 *  sin(seq(.1, 10, by = .1)), geom = 'line')
```


```{r}
sim <- paths %N>%
  mutate(food = food * env$edge_gradient) %>%
  get_distance() %>%
  accumulate(1:sim_length, ~run_sim(.x), .init = .) %>%
  .[2:sim_length]# remove the initial state
```

```{r, echo = FALSE}
anim <- sim %>%
   # map(nystuen_dacey) %>%
   map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
ggplot(aes(x, y, size = population)) +
  geom_point()+#aes(color = terminal)) +
  coord_equal() +
  theme_void() +
  labs(title = 'Year: {closest_state}') +
  transition_states(time)

animate(anim, nframes = 399)
```

```{r}
sim[[sim_length - 1]] %E>%
  maintain(paths, a = 1, b = 0) %E>%
  arrange(traffic) %>%
 # nystuen_dacey %>%
ggraph(x = x, y = y) + 
  geom_edge_fan(aes(color = log(traffic)), width = 1.2) +
   geom_node_point(aes(size = population)) +#, color = terminal)) +
  #scale_color_manual(values = c('black', 'red')) +
  scale_edge_color_viridis() +
  coord_equal() +
  theme_void()


sim[[sim_length - 1]] %E>%
  mutate(effective_distance = -1 * (effective_distance - 10)) %>%
  arrange(effective_distance) %>%
  #filter(effective_distance > 4.5) %>%
 # nystuen_dacey %>%
ggraph(x = x, y = y) + 
  geom_edge_fan(aes(color = effective_distance), width = 2) +
    geom_node_point(aes(size = population)) +#, color = terminal)) +
  #scale_color_manual(values = c('black', 'red')) +
  scale_edge_color_viridis(option = 'A') +
  coord_equal() +
  theme_void()
```
The outer ring network reminds us of central place theory (Openshaw and Veneris 2003)


So generally we see more settlements with increasing beta. With increasing alpha we get a more defined heirarchy of site sizes.

Past a beta of .4 or whatever, the patterns don't change. this is because at this point, the distance decay function attentuates at or below the baseline 10km distance between settlements. Important to not here that the interperation of the value of beta depends on the characteristic length scale.
```{r}
plan(multisession)

param_sweep <- expand.grid(alpha = seq(1, 1.5, by = 0.05),
       beta = seq(0, 0.5, by = 0.05 )) %>%
  mutate(sim = future_map2(alpha, beta, function(x, y) reduce(1:sim_length, ~run_sim(., alpha = x, beta = y, G = 0, a = 1), .init = paths), .progress = TRUE))


param_sweep[[1,3]]

saveRDS(param_sweep, 'param_sweep')
param_sweep <- readRDS('param_sweep')
test <- param_sweep %>%
  mutate(dat = map(sim, as_tibble, 'nodes')) %>%
  select(-sim) %>%
  unnest(cols = c(dat))
```

"jumps" in the parameter space (clarke and wilson 1983 or 1985, regional science). basically the relationships between alpha and beta are consistent for this

```{r}
test %>%
  filter(population, beta > 0) %>%
  ggplot(aes(log(population))) +
  geom_density(fill = 'black') +
  facet_grid(beta ~ alpha) +
  theme_classic()
```

```{r}
test %>%
  arrange(population) %>%
  filter(population > 1, 
         beta > 0) %>%
  ggplot(aes(x, y, size = population)) +
  geom_point()+
  scale_size_area() +
  coord_equal() +
  theme_void() +
  facet_grid(beta ~ alpha)


hex %>%
  mutate(x = pts[,1],
         y = pts[,2]) %>%
  left_join(test, .) %>%
    filter(beta > 0 & beta < 0.4,
         alpha < 1.4) %>%
  ggplot() +
  geom_sf(aes(fill = log(population)), color = 'white', lwd = .1) +
  scale_fill_viridis_c() +
  coord_sf(datum = NA) +
  theme_void() +
  facet_grid(beta ~ alpha)


hex %>%
  mutate(x = pts[,1],
         y = pts[,2]) %>%
  left_join(test, .) %>%
    filter(population > 1,beta > 0 & beta < 0.4,
         alpha < 1.4) %>%
  ggplot() +
  geom_sf(aes(fill = log(population))) +
  scale_fill_viridis_c() +
  coord_sf(datum = NA) +
  theme_void() +
  facet_grid(beta ~ alpha)

  ggsave('hex.png', width = 12, height = 8)
  
```


```{r}
test2 <- param_sweep %>%
  mutate(sim = future_map(sim, ~maintain(., paths, a = 1, b = 0), .progress = TRUE))
  
test2 %>%
  .[[121, 3]] %E>%
  arrange(traffic) %>%
ggraph(x = x,  y = y) +
  geom_edge_link(aes(color = log(traffic)), width = 1.2) +
  scale_edge_color_viridis() +
  coord_equal() +
  theme_void()
  
test %>%
  arrange(population) %>%
  filter(population > 1, 
         beta > 0 & beta < 0.4,
         alpha < 1.4) %>%
  ggplot(aes(x, y, size = population)) +
  geom_point()+
  scale_size_area() +
  coord_equal() +
  theme_void() +
  facet_grid(beta ~ alpha)
```
run a clustering algorithm on the outputs to determine ?regions
```{r}
test3 <- param_sweep %>%
  mutate(simsim = map(sim, ~filter(., population >= 1)),
         sim = map(sim, ~mutate(., group = group_components())),
         dat = map(sim, as_tibble, 'nodes')) %>%
  select(-sim) %>%
  unnest(cols = c(dat))


param_sweep[[120,3]] %>%
  filter(population >= 1) %>%
  mutate(group = group_components())

test3 %>%
  filter(beta > 0) %>%
  group_by(alpha, beta, group) %>%
  summarise(n_cells = n()) %>%
  ggplot(aes(n_cells)) +
  geom_histogram() +
  facet_grid(alpha ~ beta)
```


Here are two sample references: @Feynman1963118 [@Dirac1953888].


# Discussion

Edge effects -- different ways of handling them. Sidestepped here by the shear size of the domain. hexagons have low perimeter to area ratio
# Conclusion


# References {#references .unnumbered}

```{r}
knitr::knit_exit()
```


Experimenting with gdistance
```{r}
env <- matrix(1, nrow = 100, ncol = 100) %>% 
  raster(xmx = 100, ymx = 100)

euc_dist <- function(x1, x2, y1, y2){
  sqrt((x1 - x2) ^ 2 + (y1 - y2) ^2)
}

trans <- transition(env, transitionFunction = mean, directions = 8) %>%
  geoCorrection(type = 'r')

set.seed(1000)
settlements <- tbl_graph(edges = expand.grid(from = 1:n, to = 1:n),
                 nodes = tibble(population = pop_start,
                                attractiveness = 1,
                                x = sample(1:100, n, replace = TRUE),
                                y = sample(1:100, n, replace = TRUE))) %E>%
  mutate(euclidean = euc_dist(.N()$x[from], .N()$x[to], 
                             .N()$y[from], .N()$y[to])) %>%
  filter(!edge_is_loop())

sites <- settlements %N>%
  as_tibble() %>%
  select(x:y) %>%
  as.matrix

accCost(trans, sites) %>% plot

routes <- commuteDistance(trans, sites) %>%
  as.matrix %>%
  as_tbl_graph %E>%
  as_tibble %>%
  left_join(settlements, .) 


routes %>%
  as_tibble() %>%
  ggplot(aes(euclidean, weight)) + geom_point()

passage(trans, sites[2,], sites[1,], theta=5) %>% plot

plan(multicore, workers = 3)

paths <- routes %E>%
  as_tibble %>%
  filter(from > to) %>%
  mutate(passage = future_map2(from, to, ~passage(trans, sites[.x, ], sites[.y,], theta = 15)))

t1 <- paths %>% pull(passage) %>% brick %>% sum
plot(t1 / 300)

1:20 %>% accumulate(~.*(log(2) + 1), .init = t1) %>% .[[20]] %>% plot

feedback <- function(x) 

paths <- settlements %E>%
  group_by(from) %>% 
  top_n(-6, distance) %>%
  ungroup %N>%
  igraph::as.undirected(mode = 'collapse', edge.attr.comb = 'first') %>%
  as_tbl_graph
```
