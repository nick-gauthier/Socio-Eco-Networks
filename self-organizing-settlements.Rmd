---
title: Self-organizing settlement systems in variable environments
author:
  - name: Nicolas Gauthier
    email: Nicolas.Gauthier@asu.edu
    affiliation: Arizona State University
    footnote: Corresponding Author
address:
  - code: Arizona State University
    address: School of Human Evolution and Social Change, S. Caddy Mall, Tempe, AZ, Zip
abstract:

journal: "Journal of Archaeological Science"
date: "`r Sys.Date()`"
bibliography: mybibfile.bib
output:
 bookdown::pdf_book:
  base_format: rticles::elsevier_article
---


```{r echo = FALSE, eval = FALSE}
# Install necessary packages if not already available (not run by default)
install.packages(c('tidyverse', 'raster', 'RandomFields', 'tidygraph', 'gifski', 'png', 'furrr'))
#bookdown and rticles too?
# install the dev versions of these packages from github using devtools
install.packages('devtools')
devtools::install_github('thomasp85/ggraph')
devtools::install_github('thomasp85/gganimate')
devtools::install_github("thomasp85/scico")
devtools::install_github('thomasp85/patchwork')
devtools::install_github('r-spatial/sf') # need dev version for fix in st_make_Grid cell size
#devtools::install_github('ecohealthalliance/yenpathy')
```

```{r setup, include=FALSE, mesage = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = TRUE)

library(tidyverse)
library(tidygraph)
library(ggraph)
library(sf)
library(RandomFields)
library(gganimate)
library(patchwork)
library(furrr)
library(scico)
```

# Introduction

Paths are physical as well as social infrastructure. Hence the dynamics.


Archaeology is embracing the form of constrained spatial interaction modeling developed by Wilson. These Boltzmann-Lotka-Volterra (BLV) style models use maximum entropy spatial interaction models to allocate flows between a spatially structured metapopulation, and Lotka-Volterra style consumer-resource equations to govern the growth of the populations. These equations are able to capture the dynamic feedbacks between settlements and the networks connecting them. Recent work in archaeology has expanded these models to allow the networks to further evolve, as routes that are more often used to connect important sites become themselves important, which in turn shapes the growth of settlements close to those routes. Past work has shown how stable routes and sets of routes can develop in mountainous topography, where physical constraints on movement are able to constrain the possible routes between settlements. 
  
Here, I extend this approach to examine how routes and paths -- the spatial networks that connect settlements -- evolve in response to patterns of environmental variability. Rather than leaving the carrying capacity of our population of settlements to remain fixed, we allow it to vary over space and in time. We examine how different patterns of spatio-temporal change lead to different settlement patterns and spatial network. We use a simple computatational modeling approach to facilitate a broad range of exploration, while maintaining interpretive clarity. We expect that different patterns, such as fixed oscillations, to lead to different stable patterns of spatial networks, whose dynamical behavior feeds back to influence settlement dynamics. In this way we seek to model the potential for "inertia" in settlement patterns, complicating the relationship between environmental forcing and social dynamics. Finally we allow for bidirectional feedbacks between human populations and the environment, exploring the potential for nonlinear social-ecological dynamics.

We distinguish here between "routes" and "paths". The former is a social construct, the latter are physical.



  Sharing and exchange are critical for maintaining population in response to interannual climate variability, although this short term stability can come at the cost of long term environmental degradation [@Janssen2010]. More restricted sharing rules can be effective [@Hegmon1996], but can also be sensitive to the asymmetric accrual of debts if one party's food supply is more volatile than anothers' [@Crabtree2015].
 
Social infrastructure interacts directly with physical infrastructure because social networks must map onto spatial networks. Metabolic costs, such as the energy expended producing and transporting food over space where transportation infrastructure is sparse, provide constraints on energy flows in exchange systems [@Drennan1984]. In any particular case, the balance between these costs and the metabolic benefits of social interaction influences whether resources are moved in bulk to populations in need, or whether those populations move themselves to the available resources. The topology of spatial networks also constrains who can interact with whom, introducing bottlenecks and other structural flow constraints [@Barthelemy2011SpatialNetworks]. Improvements to transportation infrastructure, such as roads and trails, decrease the effective distance between different settlements; failure to maintain these transportation networks increases the effective distance [@McCall1985TheAfrica].

Regional scale patterns of spatial interaction arise from the decisions of heterogeneous agents interacting with imperfect and incomplete information. They make decisions based on the perceived costs and benefits of interaction, as far as they are able to distinguish them. It is crucial to estimate distribution of each person's subjective predictions about the costs and benefits of social interaction, conditional on the information available to them about each potential destination.

Self organization ... settlemetn patterns represent spontaneous order in response to spatial variability. positive feedbacks
anderies and hegmon 2011

cite crema 2015 for vraying caryying capcity

Lotka-Volterra equations are used in ecology to model energy flows in a food web. More generally, these models can represent energy flows in any social-ecological system, such as an agricultural settlement extracting food from the surrounding hinterland.

# Methods

We explore a simple model of agricultural settlements and their hinterlands. The base unit is a settlement, representing any urban or semi-urban population in an agrarian society that consumes food from its hinterland to support a population of non-farmers. The population engaging directly in food production is assumed to be external to the model, and instead it focuses on the population of merchants, craftspeople, and elites who rely on agricultural surplus produced in the hinterland [@Turchin2011]. The core dynamics of this urban population are represented as

$$
\dot{N} = rN,
$$
where $\dot{N}$ is the time rate of change of population $N$ and $r$ is the realized growth rate. The growth rate depends on the amount of resources consumed by $N$ as

$$
r =
  \begin{cases} 
      \epsilon \left(X -  N \right) & \text{if} \space \space\epsilon \left(X - N\right) < r_{\mathit{max}} \\
      r_{\mathit{max}} & \text{otherwise},\\
   \end{cases}
$$
where $X$ is the amount of available resource surplus, $\epsilon$ is a parameter that controls the rate at which the surplus increases or decreases the population, and $r_{\mathit{max}}$ is the maximum growth rate. This equation states that the population grows or shrinks in proportion to its consumption of resources, but it cannot grow faster a biological maximum rate. For simplicity, assume that $X$ is scaled to units of $N$ so that one unit of resource is sufficient to maintain one unit of population. The resulting process is a hybrid of exponential and logistic growth, with the population growing quickly when consumption is far above population, and more gradually when it is close (Figure \@ref(fig:growth-model)). $X$ acts as a carrying capacity, but unlike with the population's approach to this limit can be much less gradual than in logistic growth, but not as rapid as exponential growth. The population saturation occurs over a period of two to three generations.

```{r fig.cap='Simulations from the growth model, compared with exponential and logistic growth, for two levels of $X$. When $N$ is near $X$, it resembles logistic growth. When $N$ is small relative to $X$, the population grows exponentially.'}
tibble(X = c(250, 500)) %>%
  mutate(exponential = map(X, function(x) accumulate(1:599, ~ pmin(. + . * .02, x), .init = 10)),
         hybrid = map(X, function(x) accumulate(1:599, ~ . + pmin(.0001 * (x - .), .02) * .,.init = 10)),
        logistic = map(X, function(x) accumulate(1:599, ~ . + .02 * . * (1 - . / x),.init = 10))) %>%
    gather(type, N, exponential:logistic) %>%
  unnest(cols = c(N)) %>%
  mutate(time = rep(1:600, 6)) %>%
  ggplot(aes(time, N, group = type)) +
  geom_line(aes(color = type), size = 4) +
  scale_color_viridis_d(direction = -1) +
  facet_wrap(~X) +
  coord_equal() +
  theme_minimal()


growth <- function(n, x) pmin(.0001 * (x - n), .02) * n

plot(growth(1:600, 500))
# plot all x and n, or rescale
expand_grid()
```

## Spatial Interaction

The model does not track only a single settlement-hinterland system, but rather a network of hundreds of interacting settlements and hinterlands (Figure \@ref(fig:spatial-domain)). Each settlement is positioned at the center of a hexagonal hinterland of radius 5km or approximately 1hr of foot travel. A settlement is not limited to extracting food from its immediate hinterland, rather it harvests resources from multiple hinterlands. The rate at which resources are harvested from $X$ and used to increase the population of $N$ is proportional to $HXN$, where $H$ is the constant \textit{per capita} harvest rate per unit of resource. Settlements compete with one another for access to these hinterlands, and the amount of resources harvested by a given settlement is a function of its size the distance from the settlement to that hinterland along a triangular lattice, and competition with other settlements. For simplicity the harvest of resources from hinterlands is referred to as "trade", although it generally reflects any movement of food from one location to a population center in another, such as non-market forms of exchange such as sharing, exchange, or tribute.

```{r constants}
radius <- 5 # radius for each hinterland tile
phi <- radius * 0.5
pop_start <- 25 # starting population per settlement
food_start <- 200
```


```{r settlement_setup}
hinterlands <- c(40,-69, -40,-69,-80,0,-40,70,40,69,80,0,40,-69) %>% # changing one 69 in the top corner to a 70 helps for some reason
  matrix(nrow = 7, byrow = 2) %>%
  list %>%
  st_polygon %>%
  st_make_grid(cellsize = radius * sqrt(3), square = FALSE) %>% # st_make_grid wants the short diagonal
  st_sf

n <- nrow(hinterlands)

pts <- hinterlands %>%
  st_centroid %>%
  st_coordinates

settlements <- hinterlands %>%
  st_centroid %>%
  st_distance %>%
  round(2) %>%
  replace(. == 0, phi) %>%
  as_tbl_graph %>%
  mutate(population = pop_start,
         food = food_start,
         x = pts[,1], 
         y = pts[,2],
         eq = 0) %E>%
  rename(distance = weight) %>%
  mutate(trade_flow = 0,
         migrant_flow = 0)

paths <- settlements %E>% 
  filter(near(distance, sqrt(3) * radius, tol = .1)) %>%
  igraph::as.undirected() %>%
  as_tbl_graph()
```


```{r spatial-domain, fig.cap="Spatial domain for the simulation experiments. The hinterlands are 300 evenly-sized hexagons with radius 5km arranged in a continuous tiling with a total size of approximately 19,500 km2. Settlements are arranged in a triangular lattice located at the centroids of each hexagonal tile, and are connected by a system of physical paths joining each settlement to its six nearest neighbors."}
ggraph(paths, x = x, y = y) +
  geom_sf(data = hinterlands, fill = NA, color = 'grey65') +
  #geom_edge_link(alpha = .5) +
  geom_node_point() +
  coord_sf(datum = NA) +
  theme_void()
```

As in @Qubbaj2014, this simple model can be extended into a social-ecological network of multiple interconnected consumer-resource systems. First, disaggregate $X$ and $N$ into $X_i$ and $N_j$, representing the resource at location $i$ and the population at location $j$. Then, replace the constant harvest rate $H$ with an adjacency matrix $\mathbf{H}$, such that population $N_j$ harvests resource $X_i$ at rate $H_{ij}$. If $X_i$ and $N_j$ are not connected on the network, then $H_{ij} = 0$.


First, allow goods and people to flow between populations in $N$ via an adjacency matrix $\mathbf{E}$, representing a (social) food-exchange network embedded in space. $\mathbf{E}$ is derived from an entropy-maximizing spatial interaction model, which estimates the intensity of interaction between locations as a function of distance and a measure of their mutual "attractiveness" [@Wilson2011EntropyModelling]. Entropy maximization is a means of making unbiased estimates of the most likely distribution of large-scale properties of a system (in this case a spatial network), making the fewest possible assumptions about micro-scale dynamics (social networks) [@Presse2013PrinciplesPhysics]. Models that use entropy maximization to estimate the "fast" flow dynamics and consumer-resource equations such as (1) to represent the ``slow'' settlement dynamics are known as Boltzmann-Lotka-Volterra models [@Wilson2006EcologicalTheory,Wilson2008BoltzmannSystems], and useful for working with the limited information inherent to the archaeological record [@Bevan2013ModelsEvidence,Davies2014ApplicationAges,Altaweel2015EvaluatingMaximization].

The distribution of flows in $\mathbf{E}$ with the maximum entropy is determined by maximizing the flow functions subject to simple self-consistency constraints, using the method of Lagrange multipliers [@Wilson2011EntropyModelling]. The maximum entropy solution representing $E_{ij}$, the flow of resources from site $i$ to site $j$, is:


$$
    E_{ij} = \frac{O_i W_j^\alpha e^{-\beta c_{ij}}}{\sum_kW_k^\alpha e^{-\beta c_{ik}}},
$$

where $O_i$ is the total outflows from site $i$, $W$ represents a site's attractiveness to site $i$, and $c$ is some function of distance. $\alpha$ and $\beta$ are parameters derived from the Lagrange multipliers; $\beta$ is particularly relevant here as it determines the impact of distance on flow intensity, and can be varied to represent the different costs of moving food versus people across an exchange network. Here, a site's attractiveness $W$ is its \textit{per capita} food supply, $\frac{N}{X}$. This differs from the standard formulation used in geography and urban studies, where a settlement's attractiveness is only a function of its size [@Evans2011InteractionsModels]. Linking interaction intensity to food supply in this way allows the model to incorporate the influence of climate variability directly.


```{r}
interact <- function(net, fluctuation = 1, alpha_t = 1, alpha_m = 1, beta1 = 4, beta2 = 10, nu = 0.05, epsilon = .0001, rmax = .02){
  new_net <- net %E>%
    # trade
      mutate(trade_utility = .N()$population[to] ^ alpha_t * exp(-distance / beta1))  %N>%
    mutate(trade_balance = centrality_degree(weights = trade_utility, mode = 'out', loops = TRUE),
           trade_production = food * (1 + pattern * fluctuation)) %E>%
    mutate(trade_flow = .N()$trade_production[from] * trade_utility / .N()$trade_balance[from]) %N>% 
    mutate(harvest = centrality_degree(weights = trade_flow, mode = 'in', loops = TRUE)) %E>%
    # migration
    mutate(migrant_utility = (.N()$harvest[to] / .N()$population[to]) ^ alpha_m * exp(-distance / beta2)) %N>%
    mutate(migrant_balance = centrality_degree(weights = migrant_utility, mode = 'out', loops = TRUE),
           migrant_production = nu * population) %E>% # * (population / harvest) ^ 2) %E>%  # explore this
    mutate(migrant_flow = .N()$migrant_production[from] * migrant_utility / .N()$migrant_balance[from])  %N>%
    mutate(immigrants = centrality_degree(weights = migrant_flow, mode = 'in', loops = TRUE)) %>%
    # population growth
    mutate(population_new = population + population * pmin(epsilon * (harvest - population ^ .85), rmax) - migrant_production + immigrants,
           population_new = if_else(population_new > .0001, population_new, .0001),
           is_stable = abs((population_new - population) / population) < 0.0001,
           stable = if_else(is_stable == FALSE, 0, stable + 1),
           population = population_new) %>%
    select(-c(trade_balance:trade_production, migrant_balance:migrant_production, population_new, is_stable)) %E>%
    select(-c(trade_utility, migrant_utility)) %>%
    activate('nodes')

   if(sum(pull(new_net, stable) >= 100) < n){
     return(new_net)
   } else return(done(new_net))
}
```


Not only do settlements interact indirectly with one another by harvesting the same hinterland, but also directly by exchanging population through migration flows. Each model year, a fixed proportion of a settlement's population leaves each city. These migrants select their destination based on the distance to potential migration destination and the relative per capita resource extraction rate of each settlement.

The migration flows are modeled similarly to the trade flows, using a production-constrained spatial interaction model.



## Environmental Variability

The model does not account for the dynamics of agricultural production in the hinterland directly, and instead assuming a fixed baseline surplus food production each year that varies due to exogenous environmental factors (e.g. rainfall). By systematically varying the spatial and temporal patterns of surplus production, the researcher can investigate how the settlement system self organizes in response to those patterns of environmental variability.


```{r}
make_grf <- function(x, y, scale){
  mod <- RMexp(var = (food_start / 2)^2, scale = scale) + 
    RMnugget(var = .5) + 
    RMtrend(mean = food_start)
   RFsimulate(mod, x = x, y = y)$variable1
}

RFoptions(seed=100)
env <- settlements %N>%
  mutate(constant = food_start,
         grf_01 = make_grf(x, y, 1),
         grf_15 = make_grf(x, y, 15),
         grf_50 = make_grf(x, y, 50),
         gradient = scales::rescale(-1 * node_distance_from(1, weights = distance)),
         gradient2 = scales::rescale(node_distance_from(n, weights = distance)),
         oscillation = gradient + gradient2 - 1) %>%
  select(-gradient2) %>%
  as_tibble %>%
  bind_cols(hinterlands,.)
# think about scaling more

forcing_function <- expand_grid(time = 1:500, omega = c(.01, .05, .3)) %>%
  mutate(value = map2_dbl(time, omega, ~sin(.x * .y)))
```


```{r fig.width = 10, fig.height = 6, fig.cap = 'Environmental layers'}
p1 <- forcing_function %>%
  mutate(omega = ordered(omega, levels = c('0.3', '0.05', '0.01'))) %>%
  ggplot(aes(time, value, group = omega, color = omega)) +
  geom_line(size = 1.2) +
  scale_color_viridis_d(direction = -1) +
  labs(color = expression(italic(omega))) +
  theme_classic()

p2 <- env %>%
  gather(variable, value, gradient, oscillation) %>%
  mutate(variable = if_else(variable == 'gradient', 'Gradient', 'Oscillation')) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  facet_wrap(~variable, nrow = 1) +
  theme_void() +
  scale_fill_scico(palette = 'vik', direction = -1 , name = expression(italic(phi))) +
  coord_sf(datum = NA)

p3 <- env %>%
  gather(variable, value, grf_01:grf_50) %>%
  mutate(variable = as.ordered(variable),
         variable = fct_recode(variable,
                               'Autocorrelation scale = 1km' = 'grf_01',
                               'Autocorrelation scale = 15km' = 'grf_15',
                               'Autocorrelation scale = 50km' = 'grf_50')) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  facet_wrap(~variable, nrow = 1) +
  theme_void() +
  scale_fill_scico(palette = 'bamako', name = expression(hat(italic('X')))) +
  coord_sf(datum = NA)


p3 / (p1 + p2) + plot_annotation(tag_levels = 'A') + plot_layout(heights = c(2, 1))
```

```{r}
nystuen_dacey <- function(net, mode = 'trade'){
  net %E>%
  group_by(from) %>%
  {if (mode == 'trade') filter(., trade_flow == max(trade_flow)) else filter(., migrant_flow == max(migrant_flow))} %>%
  ungroup %>%
  filter(.N()$population[from] < .N()$population[to]) %N>%
  mutate(terminal = node_is_sink()) %>%
  convert(to_undirected) 
}

# try using node_is_ functions to calculate instead
```



```{r}
knitr::knit_exit()
```


# Results

Maybe try running with all environmentalattreativeness and no population feedback, but instead with the growing roads?

or disaggregate so to attractivenesses are carrying capacity and size relative to carrying capacity?




The outer ring network reminds us of central place theory (Openshaw and Veneris 2003)


So generally we see more settlements with increasing beta. With increasing alpha we get a more defined heirarchy of site sizes.

Past a beta of .4 or whatever, the patterns don't change. this is because at this point, the distance decay function attentuates at or below the baseline 10km distance between settlements. Important to not here that the interperation of the value of beta depends on the characteristic length scale.
```{r}
plan(multisession)

beta_sweep <- expand_grid(beta1 = c(0, 5, 10, 15, 20),
                           beta2 = c(0, 5, 10, 15, 20)) %>%
  mutate(sim = future_map2(beta1, beta2, function(x, y) reduce(1:2000, ~interact(., beta1 = x, beta2 = y), .init = settlements), .progress = TRUE))

1/20

saveRDS(param_sweep, 'param_sweep')
param_sweep <- readRDS('param_sweep')

test <- param_sweep %>%
  mutate(dat = map(sim, as_tibble, 'nodes'),
        nd_trade = map(sim, nystuen_dacey),
         nd_migrants = map(sim, nystuen_dacey, mode = 'migrants'))
```


```{r}
test %>%
    select(beta_t, beta_m, nd_trade) %>%
    mutate(nd = map(nd_trade, as_tibble, 'edges')) %>%
    unnest(nd) %>%
  select(beta_t, beta_m, from, to) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(alpha = .5) +
 # geom_node_point(aes(size = population)) +
  facet_edges(beta_t ~ beta_m, nrow = 5) +
  coord_equal() +
  theme_void()
```

```{r}
test %>%
    select(beta_t, beta_m, nd_migrants) %>%
    mutate(nd = map(nd_migrants, as_tibble, 'edges')) %>%
    unnest(nd) %>%
  select(beta_t, beta_m, from, to) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(alpha = .5) +
 # geom_node_point(aes(size = population)) +
  facet_edges(beta_t ~ beta_m, nrow = 5) +
  coord_equal() +
  theme_void()
```

"jumps" in the parameter space (clarke and wilson 1983 or 1985, regional science). basically the relationships between alpha and beta are consistent for this

```{r}
test %>%
  select(beta_t, beta_m, dat) %>%
  unnest(col = c(dat)) %>%
  ggplot(aes(log(population))) +
  geom_density(fill = 'black') +
  facet_grid(beta_t ~ beta_m) +
  theme_classic()
```
Explor the rank size distirbution
```{r}
test %>%
  as_tibble %>%
      select(beta_t, beta_m, dat) %>%
  unnest(col = c(dat)) %>%
  filter(population >= 1) %>%
  group_by(beta_t, beta_m) %>%
  arrange(-population) %>%
  mutate(rank = 1:n()) %>%
  ggplot(aes(rank, population)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  facet_grid(beta_t ~ beta_m, scales = 'free_y') +
  theme_classic()
```

```{r}
test %>%
  select(beta_t, beta_m, dat) %>%
  unnest(col = c(dat)) %>%
  arrange(population) %>%
  filter(population > 1) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(color = log(population)), size = 1.7)+
  scale_color_viridis_c() +
  coord_equal() +
  theme_void() +
  facet_grid(beta_t ~ beta_m)
    

hex %>%
  mutate(x = pts[,1],
         y = pts[,2]) %>%
  left_join(test %>%
  select(beta_t, beta_m, dat) %>%
  unnest(col = c(dat)), .) %>%
  ggplot() +
  geom_sf(aes(fill = log(population)), color = 'white', lwd = .1) +
  scale_fill_viridis_c() +
  coord_sf(datum = NA) +
  theme_void() +
  facet_grid(beta_t ~ beta_m)


hex %>%
  mutate(x = pts[,1],
         y = pts[,2]) %>%
  left_join(test %>%
  select(beta_t, beta_m, dat) %>%
  unnest(col = c(dat)), .) %>%
  filter(population >= 1) %>%
  ggplot() +
  geom_sf(aes(fill = log(population))) +
  scale_fill_viridis_c() +
  coord_sf(datum = NA) +
  theme_void() +
  facet_grid(beta_t ~ beta_m)

  ggsave('hex2.png', width = 12, height = 8)
  
```

How do the stable patterns reflect th underlying functions?
For exponential, looks like we could reasonably go below 0.05 and still get some interesting stuff
anything above .45 is too restrictive
```{r}
beta_check <- expand_grid(distance = 0:200,
       beta = seq(0, 1, by = 0.001 )) %>%
  mutate(exponential = exp(-beta * distance),
        logarithmic = distance ^ -beta) %>%
  gather(type, value, exponential:logarithmic)
```

```{r}
beta_check %>% filter(distance == 10, type == 'logarithmic')
```

Constrain the possible parameter space for both models. For exponential, if beta is too high then food won't move anywhere. so wehre is the threshold? maybe at least 10%. Its .23.

So exponential beta should be .01 to .25

logarithmic beta should be between .4  and 1

```{r}
beta_check %>%
  filter((distance == 10 | distance == 200), near(value, .1, tol = .01)) %>%
  group_by(distance, type) %>%
  summarise(beta = mean(beta)) %>%
  arrange(type, distance)

200^-.40
```

let's pick 5 representatives from each?

```{r}

beta_check %>%
   filter((type == 'exponential' & between(beta, .01, .25)) | (type == 'logarithmic' & between(beta, .4, 1))) %>% 
  filter(beta %% .01 == 0) %>%
  ggplot(aes(distance, value, color = beta, group = beta)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = c(5, 10), color = 'red', linetype = 2) +
  facet_wrap(~type) +
  scale_color_viridis_c() +
  theme_classic()

beta_check %>%
   filter((type == 'exponential' & beta %in% c(0, .01, .05, .1, .25)) | (type == 'logarithmic' & beta %in% c(0, .2, .4, .8, 1))) %>%
  ggplot(aes(distance, value, color = beta, group = beta)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = c(5, 10), color = 'red', linetype = 2) +
  facet_wrap(~type, nrow = 2) +
  scale_color_viridis_c() +
  theme_classic()

beta_check %>%
  filter(type == 'exponential') %>%
  filter(beta < .2 & beta >= 0 & beta %%.01 == 0) %>%
    ggplot(aes(distance, value, color = beta, group = beta)) +
  geom_line(size = 1.2) +
  geom_vline(xintercept = c(5, 10), color = 'red', linetype = 2) +
  scale_color_viridis_c() +
  theme_classic()

plot((1:30) ^ -.8)
```


run a clustering algorithm on the outputs to determine ?regions
```{r}
test3 <- param_sweep %>%
  mutate(simsim = map(sim, ~filter(., population >= 1)),
         sim = map(sim, ~mutate(., group = group_components())),
         dat = map(sim, as_tibble, 'nodes')) %>%
  select(-sim) %>%
  unnest(cols = c(dat))


param_sweep[[120,3]] %>%
  filter(population >= 1) %>%
  mutate(group = group_components())

test3 %>%
  filter(beta > 0) %>%
  group_by(alpha, beta, group) %>%
  summarise(n_cells = n()) %>%
  ggplot(aes(n_cells)) +
  geom_histogram() +
  facet_grid(alpha ~ beta)
```


now we are testing to see what the difference of initial conditions is ... doesn't look like it matters that much. makes sense, the real initial condition is the relative difference of the population centers


```{r}
nsim <- 500
sim <- settlements %N>%
   mutate(food = env$grf_100, pattern = 0) %>%
  accumulate(1:nsim, ~interact(.x), .init = .)

sim2 <- settlements %N>%
   mutate(food = env$random) %>%
  accumulate(1:nsim, ~interact(.x), .init = .)

sim3 <- settlements %N>%
   mutate(food = env$constant, pattern = 0) %>%
  accumulate(1:nsim, ~interact(.x), .init = .)
```


```{r}
sim %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>%
  ggplot(aes(time, population, group = .tidygraph_node_index)) +
  geom_line(alpha = .2) +
  theme_classic()
    
sim2 %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>%
  ggplot(aes(time, population, group = .tidygraph_node_index)) +
  geom_line(alpha = .2) +
  theme_classic()

sim3 %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>%
  ggplot(aes(time, population, group = .tidygraph_node_index)) +
  geom_line(alpha = .2) +
  theme_classic()
```


```{r, echo = FALSE}
anim <- sim3 %>%
   map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
  filter(time < 200) %>%
  #filter(time %% 10 == 0) %>%
ggplot() +
   # geom_sf(data = env, aes(fill = grf_100)) +
  geom_point(aes(x, y, size = population))+
 # coord_sf(datum = NA) +
 coord_equal() +
  # scale_fill_scico(palette = 'bamako') + 
  theme_void() +
  labs(title = 'Year: {closest_state}') +
  transition_states(time)

animate(anim, nframes = 399)
```
Below we see that, holding the distance deterrence parameters constant, the degree of spatial autocorrelation in the environment effects equilibrium territory size
```{r}
last(sim) %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_100)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
last(sim2) %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = random)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
last(sim3) %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = constant)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
```

```{r}
last(sim) %>%
  nystuen_dacey(mode = 'migrants') %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_100)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
last(sim2) %>%
  nystuen_dacey(mode = 'migrants') %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = random)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
last(sim3) %>%
  nystuen_dacey(mode = 'migrants') %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = constant)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()

```
We don't see ideal free distribution

There's not a clear relationship between size and local productivity. what about in the region?
```{r}
sim[[nsim+1]] %N>%
  as_tibble %>%
  bind_cols(env) %>%
  ggplot(aes(food, population)) +
  geom_point()
```

The larger one's hinterland is, the higher the population. not suprising
```{r}
sim[[nsim]] %>%
  mutate(hinterland = centrality_degree(weights = trade_flow, mode = 'in', loops = TRUE)) %>%
  as_tibble() %>%
  ggplot(aes(hinterland, population)) +
  geom_point() +
  geom_smooth()
```


when running time variable, maybe look at ratio of eq pop with and without?


## now add time
also thinking about running these experiments with just a single city
the problem is that cities die out early and don't have enough time 

it looks like cities will form at equilibrium where environmental variability is the least. but this might depend on the rate of change?
```{r}
sim4 <- settlements %N>%
   mutate(food = env$grf_100,
          pattern = env$gradient_oscillation) %>%
  accumulate(sin(1:1000 * .05), ~interact(.x, fluctuation = .y), .init = .)
```

so without scalking behavior you get the crazy initial growth but then it doesn't maintain. with scaling behavior it drops back off
```{r}
sim4 %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>% 
  ggplot(aes(time, (population), group = .tidygraph_node_index)) +
  geom_line(alpha = .2) +
  theme_classic()
```

```{r}
sim4 %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>% 
  ggplot(aes(food, population, group = .tidygraph_node_index, color = .tidygraph_node_index)) +
  geom_point(alpha = .2) +
  theme_classic()
```

```{r}
last(sim4) %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_100)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
```
```{r}
last(sim4) %>%
  nystuen_dacey() %>%
  mutate(group = group_components()) %>%
  as_tibble %>%
  bind_cols(env,.) %>%
  select(x, y, food, population, pattern, group) %>%
  `st_precision<-`(10) %>%
  group_by(group) %>%
  summarise(food = sum(food), population = sum(population), geometry = st_union(geometry)) %>%
  ggplot() +
  geom_sf(aes(fill = population)) +
  scale_fill_scico(palette = 'bamako')
```

```{r}
anim <- sim4 %>%
#   map(nystuen_dacey) %>%
   map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
 filter(time %% 5 == 0) %>%
ggplot() +
  #  geom_sf(data = env, aes(fill = grf_100)) +
  geom_point(aes(x, y, size = population))+#aes(color = terminal)) +
  #coord_sf(datum = NA) +
  coord_equal() +
  #scale_fill_scico(palette = 'bamako')
  theme_void() +
  labs(title = 'Year: {closest_state}') +
  transition_states(time)

animate(anim, nframes = 199)
```

It matters less if you're on productive land, more if you have access to productive land no one else does

Here are two sample references: @Feynman1963118 [@Dirac1953888].


# Discussion
constant migration rate

importance of the onset timing onset of the variability regime relative to other stuff

even fluctuation may not be realistic, translate through crop model

Edge effects -- different ways of handling them. Sidestepped here by the shear size of the domain. hexagons have low perimeter to area ratio

different functional forms for distance decay

Next, allow climate variability to influence resource dynamics. Assume a water-limited environment, so that the growth rate and carrying capacity of the resource represents the limitation of soil moisture on resource growth and abundance. The static parameters $r$ and $K$ are replaced with an unknown function $f\left(X_i, Q_i\right)$, representing logistic growth dependant on soil moisture $Q$ -- such functions are common in ecology \parencite[e.g., see][]{Ursino2007ModelingProcesses} but are kept generic here to enable application in variable ecohydrological contexts. As with $\mathbf{H}$ and $\mathbf{E}$ above, $Q$ can be replaced by an $I \times I$ adjacency matrix $\mathbf{Q}$, representing the pairwise directed moisture fluxes between all $X_i$ resource systems. This moisture-recycling network can be generated synthetically by the modeler, to explore different environmental scenarios, or estimated empirically from gridded observations, climate model outputs, or paleo-reanalysis data.

Empirical estimates of $\mathbf{Q}$ can be derived using functional network analysis, a method for inferring latent connectivity by comparing time series measured at every element of a complex system [@Donges2015UnifiedPackage]. The elements of an empirical $\mathbf{Q}$ correspond to the \textit{transfer entropy} between time series of precipitation minus evapotranspiration (i.e. the land-atmosphere moisture flux) at each grid cell of a climate model. Transfer entropy is an information-theoretic measure analogous to standard measures of correlation, but extended to capture causal dependencies between nonlinear time series [@Runge2012EscapingEntropy]. As such, a functional network representation of climate variability is conceptually and mathematically similar to the empirical orthogonal functions used in the American Southwest case but allows for more direct representations of the circulation dynamics leading to those patterns [@Donges2015]. 

Why hexagons (birch et al 2007). Edge effects of the whole hexagonal domainare slo decreased

# Conclusion


# References {#references .unnumbered}

```{r}
knitr::knit_exit()
```


Experimenting with gdistance
```{r}
env <- matrix(1, nrow = 100, ncol = 100) %>% 
  raster(xmx = 100, ymx = 100)

euc_dist <- function(x1, x2, y1, y2){
  sqrt((x1 - x2) ^ 2 + (y1 - y2) ^2)
}

trans <- transition(env, transitionFunction = mean, directions = 8) %>%
  geoCorrection(type = 'r')

set.seed(1000)
settlements <- tbl_graph(edges = expand.grid(from = 1:n, to = 1:n),
                 nodes = tibble(population = pop_start,
                                attractiveness = 1,
                                x = sample(1:100, n, replace = TRUE),
                                y = sample(1:100, n, replace = TRUE))) %E>%
  mutate(euclidean = euc_dist(.N()$x[from], .N()$x[to], 
                             .N()$y[from], .N()$y[to])) %>%
  filter(!edge_is_loop())

sites <- settlements %N>%
  as_tibble() %>%
  select(x:y) %>%
  as.matrix

accCost(trans, sites) %>% plot

routes <- commuteDistance(trans, sites) %>%
  as.matrix %>%
  as_tbl_graph %E>%
  as_tibble %>%
  left_join(settlements, .) 


routes %>%
  as_tibble() %>%
  ggplot(aes(euclidean, weight)) + geom_point()

passage(trans, sites[2,], sites[1,], theta=5) %>% plot

plan(multicore, workers = 3)

paths <- routes %E>%
  as_tibble %>%
  filter(from > to) %>%
  mutate(passage = future_map2(from, to, ~passage(trans, sites[.x, ], sites[.y,], theta = 15)))

t1 <- paths %>% pull(passage) %>% brick %>% sum
plot(t1 / 300)

1:20 %>% accumulate(~.*(log(2) + 1), .init = t1) %>% .[[20]] %>% plot

feedback <- function(x) 

paths <- settlements %E>%
  group_by(from) %>% 
  top_n(-6, distance) %>%
  ungroup %N>%
  igraph::as.undirected(mode = 'collapse', edge.attr.comb = 'first') %>%
  as_tbl_graph
```


# getting rid of edge effects
```{r}
tst <- pts
tst[,2] <- tst[,2] + max(pts[,2]) - min(pts[,2]) * .5
tst[,1] <- tst[,1] + min(pts[,1])
plot(rbind(pts, tst))

min(pts[,1])
max(pts[,2])
```

# harris wilson spatial interaction model
```{r interact}
interact <- function(net, alpha = 1.05, beta = 0.2){
  net %E>%
    mutate(utility = .N()$attractiveness[to] ^ alpha * exp(-beta * effective_distance))  %N>%
    mutate(outflow = population / centrality_degree(weights = utility,
                                                    mode = 'out', loops = FALSE)) %E>%
    mutate(flow = .N()$outflow[from] * utility) %>%
    select(-utility) %N>%
    select(-outflow)
  }

grow <- function(net, k = 1, epsilon = 0.1, G = 0.1){
  net %N>%
    mutate(inflow = centrality_degree(weights = flow, mode = 'in', loops = FALSE),
           inflow = if_else(edge == TRUE, inflow + inflow * G, inflow),
           attractiveness = attractiveness + epsilon * (inflow - k * attractiveness),
           population = n * pop_start * attractiveness / sum(attractiveness)) %>%
    select(-inflow)
}

# k convert units of flow to units of attractiveness. should be 1? we're interpreting units of flow as people, so probably not.... maybe we can say that a 1 of the climate variable is the amount of rain to produce enough food to feed xx people, and rescale from there?
```

# run sim code
need to figure out how to split the ... up to go to both sides. maybe define teh ~interact(...) outside of the accumulate commands?


```{r message = FALSE}
run_sim <- function(init, nsim = 1000, keep_intermediate = FALSE, ...){
  if(keep_intermediate == TRUE){
    sim <- accumulate(1:nsim, ~interact(.x, ...), .init = init) %>%
      map(as_tibble, 'nodes') %>%
      bind_rows(.id = 'time') %>%
      mutate(time = as.numeric(time)) # remove the initial state
  } else{
    sim <- reduce(1:nsim, ~interact(.x, ...), .init = settlements)
  }

  return(sim)
}
```

### hex sticker for silvanus!
```{r}
 paths %>%
  mutate(grf_100 = make_grf(x, y, 100)) %>%
  as_tibble %>%
  select(grf_100) %>%
  bind_cols(hex,.) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  theme_void() +
  scale_fill_scico(palette = 'oleron') +
  coord_sf(datum = NA)
```


## maintian

double check that trade flow to home regions is kept by maintain, looks like it nas out rn
```{r}
get_distance <- function(net){
  node_data <- as_tibble(net, 'nodes')
  dist_weights <- as_tibble(net, 'edges')$distance

  net %>%
    igraph::distances(weights = dist_weights) %>% # needs weight column
    replace(. == 0, 999) %>% # replace 0 values with 999 temporarily
    as_tbl_graph(directed = TRUE) %>%
    mutate(!!!node_data) %E>%
    mutate(weight = if_else(weight == 999, phi, weight)) %>%
    rename(distance = weight)
}

maintain <- function(routes, paths, a, b){
  pop <- routes %N>% pull(population)

  tmp1 <- as_tibble(routes, 'edges') %>%
    group_by(from) %>%
      nest %>%
    mutate(path = map(from, get_paths, net = paths)) %>%
    select(from, path) %>%
    unnest(cols = c(path)) %>%
    mutate(to = rep(1:n, times = n)) %>% 
    left_join(as_tibble(routes, 'edges'), .) %>%
    mutate(len = map_dbl(path, length))
  
  tmp2 <- tibble(path =  unlist(tmp1$path),
           migrant_flow = rep(tmp1$migrant_flow, times = tmp1$len),
           trade_flow = rep(tmp1$trade_flow, times = tmp1$len)) %>%
        group_by(path) %>%
        summarise(trade_flow = sum(trade_flow),
                  migrant_flow = sum(migrant_flow))

  paths %E>%
    select(-traffic) %>%
    left_join(tmp2, by = c('.tidygraph_edge_index' = 'path')) %N>%
  # mutate(total_traffic = traffic + total_traffic,
   #        effective_distance = distance * improve_path(total_traffic, a = a, b = b)) %N>%
    mutate(population = pop)
}

get_paths <- function(from, net){
    
  dist_weights <- paths %E>%
    as_tibble %>%
    pull(effective_distance)
  
  shortest_paths(net, from, weights = dist_weights, output = 'epath') %>%
    .$epath %>% 
    map(as.numeric)
}

improve_path <- function(traffic, a, b){
  (1 - a) * exp(-b * traffic) + a
}
```
