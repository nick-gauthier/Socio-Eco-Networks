---
title: Self-organizing settlement systems in variable environments
author:
  - name: Nicolas Gauthier
    email: Nicolas.Gauthier@asu.edu
    affiliation: Arizona State University
    footnote: Corresponding Author
address:
  - code: Arizona State University
    address: School of Human Evolution and Social Change, S. Caddy Mall, Tempe, AZ, Zip
abstract:

journal: "Journal of Archaeological Science"
date: "`r Sys.Date()`"
bibliography: mybibfile.bib
output:
 bookdown::pdf_book:
  base_format: rticles::elsevier_article
---


```{r echo = FALSE, eval = FALSE}
# Install necessary packages if not already available (not run by default)
install.packages(c('tidyverse', 'RandomFields', 'tidygraph', 'gifski', 'png', 'furrr'))
#bookdown and rticles too?
# install the dev versions of these packages from github using devtools
install.packages('devtools')
devtools::install_github('tidyverse/tidyr')
devtools::install_github('thomasp85/ggraph')
devtools::install_github('thomasp85/gganimate')
devtools::install_github("thomasp85/scico")
devtools::install_github('thomasp85/patchwork')
```

```{r setup, include=FALSE, mesage = FALSE}
knitr::opts_chunk$set(echo = FALSE, message = TRUE)

library(tidyverse)
library(tidygraph)
library(ggraph)
library(sf)
library(RandomFields)
library(gganimate)
library(patchwork)
library(furrr)
library(scico)
```

# Introduction

Self organization ... settlemetn patterns represent spontaneous order in response to spatial variability. positive feedbacks

Regional scale patterns of spatial interaction arise from the decisions of heterogeneous agents interacting with imperfect and incomplete information. They make decisions based on the perceived costs and benefits of interaction, as far as they are able to distinguish them. It is crucial to estimate distribution of each person's subjective predictions about the costs and benefits of social interaction, conditional on the information available to them about each potential destination.

Metabolic costs, such as the energy expended producing and transporting food over space where transportation infrastructure is sparse, provide constraints on energy flows in exchange systems [@Drennan1984]. In any particular case, the balance between these costs and the metabolic benefits of social interaction influences whether resources are moved in bulk to populations in need, or whether those populations move themselves to the available resources. 

Sharing and exchange are critical for maintaining population in response to interannual climate variability, although this short term stability can come at the cost of long term environmental degradation [@Janssen2010]. More restricted sharing rules can be effective [@Hegmon1996], but can also be sensitive to the asymmetric accrual of debts if one party's food supply is more volatile than anothers' [@Crabtree2015]. Environemntal context of exchange important [@Freemanetaal2014].

Specifically build on @Anderies2011 which explored the interaction of migration and resource heterogeneity. They used a 3 patch model to assess the role of migration and climate shocks in relation to ecological dynamics and cultural attitudes. This study presents a spatially rich extension that uses spatial interaction model to capture trade and migration flows within a structured population of settlements.

The network matters. The topology of spatial networks also constrains who can interact with whom, introducing bottlenecks and other structural flow constraints [@Barthelemy2011SpatialNetworks,@qubbaj20111]. Improvements to transportation infrastructure, such as roads and trails, decrease the effective distance between different settlements; failure to maintain these transportation networks increases the effective distance [@McCall1985TheAfrica].
  
Archaeology is embracing the form of constrained spatial interaction modeling developed by Wilson. These Boltzmann-Lotka-Volterra (BLV) style models use maximum entropy spatial interaction models to allocate flows between a spatially structured metapopulation, and Lotka-Volterra style consumer-resource equations to govern the growth of the populations. Lotka-Volterra equations are used in ecology to model energy flows in a food web. More generally, these models can represent energy flows in any social-ecological system, such as an agricultural settlement consuming resources from its hinterland.

These equations are able to capture the dynamic feedbacks between settlements and the networks connecting them. Recent work in archaeology has expanded these models to allow the networks to further evolve, as routes that are more often used to connect important sites become themselves important, which in turn shapes the growth of settlements close to those routes. Past work has shown how stable routes and sets of routes can develop in mountainous topography, where physical constraints on movement are able to constrain the possible routes between settlements. 

Here, I extend this approach to examine how settlement systems evolve in response to patterns of environmental variability. Rather than leaving the carrying capacity of our population of settlements to remain fixed, we allow it to vary over space and in time. We examine how different patterns of spatio-temporal change lead to different settlement patterns and spatial network. We use a simple computatational modeling approach to facilitate a broad range of exploration, while maintaining interpretive clarity. We expect that different patterns, such as fixed oscillations, to lead to different stable patterns of spatial networks, whose dynamical behavior feeds back to influence settlement dynamics. In this way we seek to model the potential for "inertia" in settlement patterns, complicating the relationship between environmental forcing and social dynamics. Finally we allow for bidirectional feedbacks between human populations and the environment, exploring the potential for nonlinear social-ecological dynamics.

# Methods

We explore a simple model of human settlements and their agricultural hinterlands. The base unit is a settlement, representing any urban or semi-urban population in an agrarian society that consumes food from its hinterland to support a population of non-farmers. The population engaging directly in food production is assumed to be external to the model, and instead it focuses on the population of merchants, craftspeople, and elites who rely on agricultural surplus produced in the hinterland [@Turchin2011]. The core dynamics of this urban population are represented as

$$
\dot{N} = rN,
$$
where $\dot{N}$ is the time rate of change of population $N$ and $r$ is the realized growth rate. The growth rate depends on the amount of resources consumed by $N$ as

$$
r =
  \begin{cases} 
      \epsilon \left(X -  N \right) & \text{if} \space \space\epsilon \left(X - N\right) < r_{\mathit{max}} \\
      r_{\mathit{max}} & \text{otherwise},\\
   \end{cases}
$$
where $X$ is the amount of available resource surplus, $\epsilon$ is a parameter that controls the rate at which the surplus increases or decreases the population, and $r_{\mathit{max}}$ is the maximum growth rate. This equation states that the population grows or shrinks in proportion to its consumption of resources, but it cannot grow faster a biological maximum rate. For simplicity, assume that $X$ is scaled to units of $N$ so that one unit of resource is sufficient to maintain one unit of population. The resulting process is a hybrid of exponential and logistic growth, with the population growing quickly when consumption is far above population, and more gradually when it is close (Figure \@ref(fig:growth-model)). $X$ acts as a carrying capacity, but unlike with the population's approach to this limit can be much less gradual than in logistic growth, but not as rapid as exponential growth. The population saturation occurs over a period of two to three generations.

```{r}
grow <- function(net, epsilon = .0001, rmax = .02){
  net %N>%
     mutate(population_new = population + population * pmin(epsilon * (harvest - population), rmax) - migrant_production + immigrants,
           population_new = if_else(population_new > .0001, population_new, .0001),
           eq = if_else(abs((population_new - population) / population) > 0.001, 0, eq + 1),
           population = population_new)
}
```


```{r fig.cap='Simulations from the growth model, compared with exponential and logistic growth, for two levels of $X$. When $N$ is near $X$, it resembles logistic growth. When $N$ is small relative to $X$, the population grows exponentially.'}

x_text <- tibble(x = c(350, 400), 
       y = c(100,350), 
       X = c(250, 500),
       text = paste('X = ', X))

p1 <- tibble(X = c(250, 500)) %>%
  mutate(exponential = map(X, function(x) accumulate(1:499, ~ pmin(. + . * .02, x), .init = 10)),
         hybrid = map(X, function(x) accumulate(1:499, ~ . + pmin(.0001 * (x - .), .02) * .,.init = 10)),
        logistic = map(X, function(x) accumulate(1:499, ~ . + .02 * . * (1 - . / x),.init = 10))) %>%
  gather(type, N, exponential:logistic) %>%
  unnest(cols = c(N)) %>%
  mutate(time = rep(1:500, 6)) %>%
  ggplot(aes(time, N)) +
  geom_line(aes(color = type, group = type), size = 1.2) +
  scale_color_viridis_d(direction = -1, name = 'Growth function') +
  facet_wrap(~X) +
  geom_text(data = x_text, aes(x = x, y = y, label = text)) +
  labs(x = 'Year', y = 'Population') +
  theme_classic() +
  theme(strip.background = element_blank(),
  strip.text.x = element_blank())


p2 <- expand_grid(distance = 0:100,
       beta =  c(1, 5, 10, 15, 20)) %>%
  mutate(deterrence = exp(-distance / beta)) %>%
  mutate(beta = as.ordered(beta)) %>%
    ggplot(aes(distance, deterrence, color = beta, group = beta)) +
  geom_line(size = 1.2) +
  scale_color_viridis_d(name = expression(italic(beta))) +
  labs(x = 'Distance (km)', y = 'Interaction strength') +
  theme_classic()

expand_grid(nu = (2:8)/100,
            welfare = (1:100) / 100) %>%
  mutate(production = .5 * plogis(welfare, scale = nu, location = .75)) %>%
  ggplot(aes(welfare, production, color = as.ordered(nu))) +
  geom_line(size = 1.2) +
  geom_hline(yintercept = .5) +
  theme_classic()




plot(.5 * plogis(1:100/100,scale = .05, location = .7))

p1 / p2 + plot_annotation(tag_levels = 'A')
```

## Spatial Interaction

The model does not track only a single settlement-hinterland system, but rather a network of hundreds of interacting settlements and hinterlands (Figure \@ref(fig:spatial-domain)). Each settlement is positioned at the center of a hexagonal hinterland of radius 5km or approximately 1hr of foot travel. A settlement is not limited to extracting food from its immediate hinterland, rather it harvests resources from multiple hinterlands. The rate at which resources are harvested from $X$ and used to increase the population of $N$ is proportional to $HXN$, where $H$ is the constant \textit{per capita} harvest rate per unit of resource. Settlements compete with one another for access to these hinterlands, and the amount of resources harvested by a given settlement is a function of its size the distance from the settlement to that hinterland along a triangular lattice, and competition with other settlements. For simplicity the harvest of resources from hinterlands is referred to as "trade", although it generally reflects any movement of food from one location to a population center in another, such as non-market forms of exchange such as sharing, exchange, or tribute.

```{r constants}
radius <- 5 # radius for each hinterland tile
phi <- radius * 0.5
pop_start <- 25 # starting population per settlement
food_start <- 200
```


```{r settlement_setup}
hinterlands <- c(40,-69, -40,-69,-80,0,-40,70,40,69,80,0,40,-69) %>% # changing one 69 in the top corner to a 70 helps for some reason
  matrix(nrow = 7, byrow = 2) %>%
  list %>%
  st_polygon %>%
  st_make_grid(cellsize = radius * sqrt(3), square = FALSE) %>% # st_make_grid wants the short diagonal
  st_sf

n <- nrow(hinterlands)

pts <- hinterlands %>%
  st_centroid %>%
  st_coordinates

settlements <- hinterlands %>%
  st_centroid %>%
  st_distance %>%
  round(2) %>%
  replace(. == 0, 999) %>%
  as_tbl_graph %>%
  mutate(id = 1:n(),
         population = pop_start,
         food = food_start,
         x = pts[,1], 
         y = pts[,2],
         eq = 0) %E>%
  rename(distance = weight) %>%
  mutate(distance = if_else(distance == 999, 0, distance),
         trade_flow = 0,
         migrant_flow = 0) 

prune <- function(net, beta, tolerance = 0.001){
  net %E>%
    filter(distance < -log(tolerance) * beta)
}
  

# the larger your domain grows the more potential connections there will be, which can
# increase computational costs significantly. We can fix this by filtering out edges defined
# at a certain threshold. if we're using the exponetial beta parameterization, we can truncate using the following command, where the term in the log is the minimum distance effect we want to capture. We'll set it to .005, which if we assume food is 200 gives us 1. so at a maximum parameterization of beta = 20, truncating the network at this distance serves to elimitate flows that will be lses than .5% or 1 food.


paths <- settlements %E>% 
  filter(near(distance, sqrt(3) * radius, tol = .1)) %>%
  igraph::as.undirected() %>%
  as_tbl_graph()
```


```{r spatial-domain, fig.cap="Spatial domain for the simulation experiments. The hinterlands are 300 evenly-sized hexagons with radius 5km arranged in a continuous tiling with a total size of approximately 19,500 km2. Settlements are arranged in a triangular lattice located at the centroids of each hexagonal tile, and are connected by a system of physical paths joining each settlement to its six nearest neighbors."}
ggraph(paths, x = x, y = y) +
  geom_sf(data = hinterlands, fill = NA, color = 'grey65') +
  #geom_edge_link(alpha = .5) +
  geom_node_point() +
  coord_sf(datum = NA) +
  theme_void()
```

As in @Qubbaj2014, this simple model can be extended into a social-ecological network of multiple interconnected consumer-resource systems. First, disaggregate $X$ and $N$ into $X_i$ and $N_j$, representing the resource at location $i$ and the population at location $j$. Then, replace the constant harvest rate $H$ with an adjacency matrix $\mathbf{H}$, such that population $N_j$ harvests resource $X_i$ at rate $H_{ij}$. If $X_i$ and $N_j$ are not connected on the network, then $H_{ij} = 0$.


First, allow goods and people to flow between populations in $N$ via an adjacency matrix $\mathbf{E}$, representing a (social) food-exchange network embedded in space. $\mathbf{E}$ is derived from an entropy-maximizing spatial interaction model, which estimates the intensity of interaction between locations as a function of distance and a measure of their mutual "attractiveness" [@Wilson2011EntropyModelling]. Entropy maximization is a means of making unbiased estimates of the most likely distribution of large-scale properties of a system (in this case a spatial network), making the fewest possible assumptions about micro-scale dynamics (social networks) [@Presse2013PrinciplesPhysics]. Models that use entropy maximization to estimate the "fast" flow dynamics and consumer-resource equations such as (1) to represent the ``slow'' settlement dynamics are known as Boltzmann-Lotka-Volterra models [@Wilson2006EcologicalTheory,Wilson2008BoltzmannSystems], and useful for working with the limited information inherent to the archaeological record [@Bevan2013ModelsEvidence,Davies2014ApplicationAges,Altaweel2015EvaluatingMaximization].

The distribution of flows in $\mathbf{E}$ with the maximum entropy is determined by maximizing the flow functions subject to simple self-consistency constraints, using the method of Lagrange multipliers [@Wilson2011EntropyModelling]. The maximum entropy solution representing $E_{ij}$, the flow of resources from site $i$ to site $j$, is:


$$
    E_{ij} = \frac{O_i W_j^\alpha e^{-\beta c_{ij}}}{\sum_kW_k^\alpha e^{-\beta c_{ik}}},
$$

where $O_i$ is the total outflows from site $i$, $W$ represents a site's attractiveness to site $i$, and $c$ is some function of distance. $\alpha$ and $\beta$ are parameters derived from the Lagrange multipliers; $\beta$ is particularly relevant here as it determines the impact of distance on flow intensity, and can be varied to represent the different costs of moving food versus people across an exchange network. Here, a site's attractiveness $W$ is its \textit{per capita} food supply, $\frac{N}{X}$. This differs from the standard formulation used in geography and urban studies, where a settlement's attractiveness is only a function of its size [@Evans2011InteractionsModels]. Linking interaction intensity to food supply in this way allows the model to incorporate the influence of climate variability directly.

As a shorthand call beta1 "transport" ease and beta2 "travel" ease

```{r}
trade <- function(net, alpha, beta, phi = radius / 2, fluctuation){
  net %E>%
   mutate(trade_utility = .N()$population[to] ^ alpha * exp(-if_else(distance > 0, distance, phi) / beta))  %N>%
    mutate(trade_balance = centrality_degree(weights = trade_utility, mode = 'out', loops = TRUE),
           trade_production = food * (1 + anomaly * fluctuation)) %E>%
    mutate(trade_flow = .N()$trade_production[from] * trade_utility / .N()$trade_balance[from]) %N>% 
    mutate(harvest = centrality_degree(weights = trade_flow, mode = 'in', loops = TRUE))
}
```

Not only do settlements interact indirectly with one another by harvesting the same hinterland, but also directly by exchanging population through migration flows. Each model year, a fixed proportion of a settlement's population leaves each city. These migrants select their destination based on the distance to potential migration destination and the relative per capita resource extraction rate of each settlement.

The migration flows are modeled similarly to the trade flows, using a production-constrained spatial interaction model.
murilo et al 2017 and anderies and hegmon 20xx

$$
  M = \frac{0.5}{1 + e^{-(x - \mu) / 
\nu} }
$$

```{r}
migrate <- function(net, alpha1, alpha2, beta, nu = 0.05){
  net %E>%
    mutate(migrant_utility =.N()$population[to] ^ alpha1 * (.N()$harvest[to] / .N()$population[to]) ^ alpha2 * exp(-distance / beta)) %N>%
    mutate(migrant_balance = centrality_degree(weights = migrant_utility, mode = 'out', loops = TRUE),
           migrant_production = nu * population) %E>% 
    mutate(migrant_flow = .N()$migrant_production[from] * migrant_utility / .N()$migrant_balance[from])  %N>%
    mutate(immigrants = centrality_degree(weights = migrant_flow, mode = 'in', loops = TRUE))
}
```

The entire system is composed of complicated nonlinear equations, as the growth and decline of settements can potentialy depend on al other settlements. Refer to @Anderies2011 for analytical exploration of a similar model. Now we use simulation to better understand the behavior of this model in different enviromental contexts.

```{r}
interact <- function(net, fluctuation = 1, alpha1 = 1.15, alpha2 = 1, beta1 = 5, beta2 = 10){
  new_net <- net %E>%
    trade(alpha = alpha1, beta = beta1, fluctuation = fluctuation) %>%
    migrate(alpha1 = alpha1, alpha2 = alpha2, beta = beta2) %>%
    grow %>%
    select(-c(trade_balance:trade_production, migrant_balance:migrant_production, population_new)) %E>%
    select(-c(trade_utility, migrant_utility)) %>%
    activate('nodes')

   if(sum(pull(new_net, eq) >= 100) < n){
     return(new_net)
   } else return(done(new_net))
}
```


## Environmental Variability

The model does not account for the dynamics of agricultural production in the hinterland directly, and instead assuming a fixed baseline surplus food production each year that varies due to exogenous environmental factors (e.g. rainfall). By systematically varying the spatial and temporal patterns of surplus production, the researcher can investigate how the settlement system self organizes in response to those patterns of environmental variability.

The climate anomalyis the spatial pattern.


Rainfall varies smoothly, but it is important that crop yields do not vary linearly with rainfall. Yield should be a declining function of yield, such that given normal variability the risk of crop failure is higher than if there hadnt been any.
Simple power function of rainfall is crop productionfunction

```{r}
make_grf <- function(x, y, scale){
  mod <- RMexp(var = (food_start / 3)^2, scale = scale) + 
    RMnugget(var = .5) + 
    RMtrend(mean = food_start)
   RFsimulate(mod, x = x, y = y)$variable1
}

RFoptions(seed=100)
env <- settlements %N>%
  mutate(constant = food_start,
         grf_01 = make_grf(x, y, 1),
         grf_15 = make_grf(x, y, 15),
         grf_50 = make_grf(x, y, 50),
         gradient = scales::rescale(-1 * node_distance_from(1, weights = distance)),
         gradient2 = scales::rescale(node_distance_from(n, weights = distance)),
         oscillation = gradient + gradient2 - 1) %>%
  select(-gradient2) %>%
  as_tibble %>%
  bind_cols(hinterlands,.)
# think about scaling more

forcing_function <- expand_grid(time = 1:500, omega = c(.01, .05, .3)) %>%
  mutate(value = map2_dbl(time, omega, ~sin(.x * .y)))
```


```{r fig.width = 10, fig.height = 6, fig.cap = 'Environmental layers'}
p1 <- forcing_function %>%
  mutate(omega = ordered(omega, levels = c('0.3', '0.05', '0.01'))) %>%
  ggplot(aes(time, value, group = omega, color = omega)) +
  geom_line(size = 1.2) +
  scale_color_viridis_d(direction = -1) +
  labs(color = expression(italic(omega))) +
  theme_classic()

p2 <- env %>%
  gather(variable, value, gradient, oscillation) %>%
  mutate(variable = if_else(variable == 'gradient', 'Gradient', 'Oscillation')) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  facet_wrap(~variable, nrow = 1) +
  theme_void() +
  scale_fill_scico(palette = 'vik', direction = -1 , name = expression(italic(phi))) +
  coord_sf(datum = NA)

p3 <- env %>%
  gather(variable, value, grf_01:grf_50) %>%
  mutate(variable = as.ordered(variable),
         variable = fct_recode(variable,
                               'Autocorrelation scale = 1km' = 'grf_01',
                               'Autocorrelation scale = 15km' = 'grf_15',
                               'Autocorrelation scale = 50km' = 'grf_50')) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  facet_wrap(~variable, nrow = 1) +
  theme_void() +
  scale_fill_scico(palette = 'bamako', name = expression(hat(italic('X')))) +
  coord_sf(datum = NA)


p3 / (p1 + p2) + plot_annotation(tag_levels = 'A') + plot_layout(heights = c(2, 1))
```


```{r}
yield <- function(rainfall){
  1 * pmax(0, 0.51 * log(rainfall) + 1.03)  # annual rainfall impact on yields
}

0.51 * log((rainfall)) + 1.03
plot((0:200)/100, yield((0:200)/100), ylim = c(0, 1.5))

plot((0:200)/100, 1.03 * ((0:200)/100)^.5  + 1,ylim = c(0, 1.5))
```

```{r}
nystuen_dacey <- function(net, mode = 'trade'){
  net %E>%
  group_by(from) %>%
  {if (mode == 'trade') filter(., trade_flow == max(trade_flow)) else filter(., migrant_flow == max(migrant_flow))} %>%
  ungroup %>%
  filter(.N()$population[from] < .N()$population[to]) %N>%
  mutate(terminal = node_is_sink()) %>%
  convert(to_undirected) 
}

# try using node_is_ functions to calculate instead
```



```{r}
knitr::knit_exit()
```


# Results

First I explore baseline sensitivity of the model to key tuning parameters. interaction parameters $\beta_1$ and $beta_2$ governing the distance deterrence for trade and migration, respectively.

We only assume that all $\alpha >= 1$, that is there are positive returns to scale in attractiveness, and $\beta_1 \leq \beta_2$ because moving food over the landscape should be more difficult than moving people. 

```{r, eval=FALSE}
plan(multisession)

param_sweep <- expand_grid(beta1 = c(5, 10, 15, 20),
                           beta2 = c(5, 10, 15, 20),
                          alpha1 = c(1, 1.05, 1.15),
                          alpha2 = c(1, 1.05, 1.15),
                          alpha3 = c(0, 1),
                          gamma = c(.85, 1)) %>%
  filter(beta1 <= beta2) %>%
  mutate(sim = future_pmap(list(beta1, beta2, alpha1, alpha2, alpha3, gamma), function(a,b,c,d,e,f) reduce(1:2000, ~interact(., beta1 = a, beta2 = b, alpha1 = c, alpha2 = d, alpha3 = e, gamma = f), .init = settlements %N>% mutate(anomaly = 0)), .progress = TRUE))

saveRDS(param_sweep, 'param_sweep')
```

```{r}
param_sweep <- readRDS('param_sweep') %>%
  mutate(dat = map(sim, as_tibble, 'nodes'),
        nd_trade = map(sim, nystuen_dacey),
         nd_migrants = map(sim, nystuen_dacey, mode = 'migrants'))
```

Rank size distribution. Increasing $\beta_2$ increases the convexity of the rank size distribution. Increasing $\beta_1$ decreases it

```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  unnest(col = c(dat)) %>%
  select(beta1:gamma, population, x, y, harvest, immigrants) %>%
  filter(alpha1 == 1, alpha2 == 1, alpha3 == 0, gamma == 1) %>%
  group_by(beta1, beta2) %>%
  arrange(-population) %>%
  mutate(rank = 1:n()) %>%
  ggplot(aes(rank, population)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  scale_y_log10() +
  facet_grid(rows = vars(beta1), cols = vars(beta2), scales = 'free_y') +
  theme_classic()
```

The general pattern is a spatial doubling bifurcation
With baseline values of $\alpha_1 = \alpha_2 = 1$, $\alpha_3 = 0$ and $\gamma = 1$ (that is, no scaling behavior or hunger based movement). Increasing $\beta_1$, allowing food to be moved further distances, decreases the number of inhabitet settlements at equilibrium and increases the size of these centers (though not as much as migration). The settlements also move closer to the center of the domain, as that supplies tha maximum access to resources. Holding $\beta_1$ constant and varying $\beta_2$ allowing migrants to move further than food. The result is a pattern of concentrric rings at low values of beta1. When it is difficult to move food over space, migration acts in lieu of food tranpsort by increasing the size of the terminal centers (allowing population to move to populated zones). But at beta2 = 15 there is a switch, where now the center is filled with multiple settlements of similar size in a hexagon pattern. The number of settlemetns in this central zone increases with increasing migration. IT seems that this might be a rsult of the size and shape of the spatial domain, as at long distance interaction the size and shape of the domain more strongly constrains the possible configurations. These inner zones decrease at increasing beta1, suggesting that what's happing is at low values of beta1 settlements must extact from their immediate area. Settlements at the edge get inital advangtages because they have fewer nearby cities competeing with them for resources. At low beta2, this doesn't matter as much, but at high beta2 it sets of a feedback because population migrates to the sites with initial advantages. When beta1 is higher, beta2 doesn't neceesaryily change the patterns that much, just serves to concentrate more poeple in fewer core settlemetns that are closer together. At the highest values of beta and beat2, the hexagonal core returns, if smaller than in the low beta1 case. The key feature to my mind is the bifurcation between $\beta_1$ at 5 and 10. This is the showing difference above and below the distance of the nearest cell neighbor given the cell resoltion (nearest distance is approximately 8km). If transportation technology allows food to move more easily between scales, that process dominates and the system organizes around the territorial reach of each settlements, and the resulting feedbacks with food flows and size predominate. When beta1 is low/transport tech is low, it is harder to move food between terirtories and migration predominates in shaping settlement patterns.Likewsie, there isn't much of adiffernce between the 10 and 15 threshold because that's still between settlements (the distances are 8 and 17)

So that middle zone thing only happens when alpha 3 is zero. That is it is a result of the population seeking behavior. When we allow people to avoid locations near carrying capacity, the system is allowed to balance out better.

Although these are edge effects, this does have important implications for for geographically bounded systems. Variations in transport capacity only matter up to the constraint of maximum travelable distance. decreasing transport and travel costs ()
```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  unnest(col = c(dat)) %>%
  select(beta1:gamma, population, x, y, harvest, immigrants) %>%
  filter(alpha1 == 1.15, alpha2 == 1.15, alpha3 == 1, gamma == 1) %>%
  group_by(beta1, beta2)%>%
  #filter(beta1 == 5) %>%
  arrange(population) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(size = population, color = population))+
  scale_size_area() +
  scale_color_viridis_c(guide = 'legend') +
  coord_equal() +
  theme_void() +
  facet_grid(rows = vars(beta1), cols = vars(beta2))
```
Introducing scaleing parameters to the population size doesn't change the basic interaction between the betas. It does greatly increase the population size. Incorporating alpha3 does change the settlemnt patterns somewhat.. But again the basic relationship between beta1 and beta2 doesn't change

the center zone behavior arises if we set alpha1=alpha2, and turn on alpha3. that is all the alphas are the same, then the population center hexagon arises much faster, at lower values of beta2, and is much larger. It goes away if we turn on scaling for gamma. This suggests the case where movement is easy, but there are few advantages to living in larger sites, and what adantages do arise are equalized by the alpha3 bejavior
```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  unnest(col = c(dat)) %>%
  select(beta1:gamma, population, x, y, harvest, immigrants) %>%
  filter(alpha1 == 1.15, alpha2 == 1.15, alpha3 == 1, gamma == 1) %>%
  group_by(beta1, beta2)%>%
  arrange(population) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(size = (population), color = (population)))+
  scale_size_area() +
  scale_color_viridis_c() +
  coord_equal() +
  theme_void() +
  facet_grid(rows = vars(beta1), cols = vars(beta2))
```
Constaining beta1 to 5 and beta2 to 10, then exploring alphas. All else being equal, we'd assume $\alpha_1 = \alpha_2$ since they both relate the the scaling with population size, and the differences in the importance of population size between travel and transport attractiveness would be introduced by the prefactor (which get's cancelled here given the normalization). Nevertheless we explore different combinations of alphas. Generally, increasing eigher alpha increases the concentration of popualtions in fewer centers. As before, the settlemetns near the edge grow higherst, because there is less competition for access to resources. Turning on alpha 3, so that people avoid crowded locations, considerably icnreases the complexity of the system. This removes the apparent similarity between the alphas, with more nonlinear responses

```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  unnest(col = c(dat)) %>%
  select(beta1:gamma, population, x, y, harvest, immigrants) %>%
  filter(beta1 == 5, beta2 == 10, alpha3 == 1, gamma == 1) %>%
  group_by(alpha1, alpha2)%>%
  arrange(population) %>%
  ggplot(aes(x, y)) +
  geom_point(aes(size = population, color = population))+
  scale_size_area() +
  scale_color_viridis_c(guide = 'legend') +
  coord_equal() +
  theme_void() +
  facet_grid(rows = vars(alpha1), cols = vars(alpha2))
```

let's analyze the patterns statistically. we calculate the total population of each simulation, and the relative shannon entropy of the population distribution, and index of dispersion. Values of 0 indicatea fully concentrated in a single point systen, 1 is as dispersed as possible. From this we see gamma greatly increases the max population, enough so that its hard to see. with gamma = .85, we see a roughly linear decline in entropy (ie increasing concentration with increasing settlement size). No such relationship with gamma = 1. Bsaically it seems that gamma is so powerful it swamps out other considerations.
```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  mutate(population = map_dbl(dat, ~sum(.$population)),
         prob_vect = map2(dat, population, ~ (.x$population) / .y),
         entropy = map_dbl(prob_vect, ~ -sum(. * log(.)) / log(300))) %>%
  select(beta1:gamma, population, entropy) %>%
  ggplot(aes(population, entropy)) + geom_point(aes(color = gamma)) + facet_wrap(~gamma, scales = 'free_x')
```
So looking at the parametr combinations that lead to high poplation or high concentration ... low beta1 and high beta2 have the highest population, more sensitive to beta1, and alphas set to 0, and alpha 2 more important to be low than otherwise. This is what we saw in the graphs with the large central areas, which reflect low transport costs and low returns to scale. For the entropy case, low beta1 means higher etnropy (ie more dispersion). Beta2 maetters less, and again with low or no scaling. having alpha3 in the mix also increases dispersion, all as we'd expect.
```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  mutate(population = map_dbl(dat, ~sum(.$population)),
         prob_vect = map2(dat, population, ~ (.x$population) / .y),
         entropy = map_dbl(prob_vect, ~ -sum(. * log(.)) / log(300))) %>%
  select(beta1:gamma, population, entropy) %>%
  filter(gamma == 1) %>%
  arrange(-entropy)
```

intrestingly, there seems to be very little variability around beta1 is 15, that's when we get to 3 city attractor. beta 2 increasing slightly decrases entropy, but not as strongly as beta1. having alpha3 in the mix slightly increases the entropy, but the boxplots are still within the range of one another as we might expect
```{r}
param_sweep %>%
  select(beta1:gamma, dat) %>%
  mutate(population = map_dbl(dat, ~sum(.$population)),
         prob_vect = map2(dat, population, ~ (.x$population) / .y),
         entropy = map_dbl(prob_vect, ~ -sum(. * log(.)) / log(300))) %>%
  select(beta1:gamma, population, entropy) %>%
  filter(gamma == 1) %>%
  ggplot(aes(beta1, entropy, group = beta1)) + geom_boxplot()

param_sweep %>%
  select(beta1:gamma, dat) %>%
  mutate(population = map_dbl(dat, ~sum(.$population)),
         prob_vect = map2(dat, population, ~ (.x$population) / .y),
         entropy = map_dbl(prob_vect, ~ -sum(. * log(.)) / log(300))) %>%
  select(beta1:gamma, population, entropy) %>%
  ggplot(aes(gamma, entropy, group = gamma)) + geom_boxplot()
```

So what does this all leave us with. Beta1 governs the spacing of the centers, beta2 and alphas more impact the population distirbution. Alphas specifically increase the heirarchies

So generally we see more settlements with decreasing beta. With increasing alpha we get a more defined heirarchy of site sizes.

Past a beta of .4 or whatever, the patterns don't change. this is because at this point, the distance decay function attentuates at or below the baseline 10km distance between settlements. Important to not here that the interperation of the value of beta depends on the characteristic length scale.

```{r}
param_sweep %>%
    select(beta1, beta2, nd_trade) %>%
    mutate(nd = map(nd_trade, as_tibble, 'edges')) %>%
    unnest(nd) %>%
  select(beta1, beta2, from, to) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(alpha = .5) +
  facet_edges(beta1 ~ beta2, ncol= 5) +
  coord_equal() +
  theme_void()
```
We can agian confrim the genral patterns above by looking at the nystuen dacey graphs. Confirming that the mass of same sized sites reflects that they have no nystuen dacey graph for trade, ie they're all competing for the same land and no clear winner gets the flows. We do get migrants out from the core to the edge sites, hence the hexagonal pattern of the core zone. these patterns arent particularly sensitive to the alphas.
```{r}
#trade
param_sweep %>%
  filter(alpha1 == 1.15, alpha2 == 1.15, alpha3 == 1, gamma == 1)  %>%
    mutate(nd = map(nd_trade, as_tibble, 'edges')) %>%
    select(beta1:gamma, nd) %>%
    unnest(nd) %>%
  select(beta1, beta2, from, to) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(alpha = .5) +
  facet_edges(beta1 ~ beta2) +
  coord_equal() +
  theme_void()

#migrants
param_sweep %>%
  filter(alpha1 == 1.15, alpha2 == 1.15, alpha3 == 1, gamma == 1)  %>%
    mutate(nd = map(nd_migrants, as_tibble, 'edges')) %>%
    select(beta1:gamma, nd) %>%
    unnest(nd) %>%
  select(beta1, beta2, from, to) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(alpha = .5) +
  facet_edges(beta1 ~ beta2) +
  coord_equal() +
  theme_void()
```

But remember, in the case of the migration flows, the nd graph might be misleading because you can have significant flows of migration between the large cities, even if the nystuen dacey graph hides this.

```{r}
param_sweep %>%
  filter(alpha1 == 1.15, alpha2 == 1.15, alpha3 == 1, gamma == 1)  %>%
    mutate(flows = map(sim, as_tibble, 'edges')) %>%
    select(beta1:gamma, flows) %>%
    unnest(flows) %>% 
  select(beta1, beta2, from, to, trade_flow) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %E>%
  filter(trade_flow > 10) %>%
  arrange(trade_flow) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = trade_flow), width = 1.2) +
  scale_edge_color_viridis() +
  facet_edges(beta1 ~ beta2) +
  coord_equal() +
  theme_void()
```

So from this we see that a bif proportion of the migrant flows go inward. Is this ok? its consistent with the potential behavior of the qubbaj model. But perhaps not if we introduce bariable migration
```{r}
param_sweep %>%
  filter(alpha1 == 1.15, alpha2 == 1.15, alpha3 == 1, gamma == 1)  %>%
    mutate(flows = map(sim, as_tibble, 'edges')) %>%
    select(beta1:gamma, flows) %>%
    unnest(flows) %>% 
  select(beta1, beta2, from, to, migrant_flow) %>%
  tbl_graph(nodes = as_tibble(paths, 'nodes'), edges = .) %E>%
  filter(migrant_flow > 10) %>%
  filter(from != to) %>%
  arrange(migrant_flow) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = migrant_flow), width = 1.2) +
  scale_edge_color_viridis() +
  facet_edges(beta1 ~ beta2) +
  coord_equal() +
  theme_void()
```

"jumps" in the parameter space (clarke and wilson 1983 or 1985, regional science). basically the relationships between alpha and beta are consistent for this

Explor the rank size distirbution

Hard to see here, but for beta = 1 we can really see the effect of migration, longer migration distance leads to some pooling in center.
But in general, variation due to trade swamps that from migration, becuase trade also shapes migration but less so the other way around.



The parameters $\beta$



now we are testing to see what the difference of initial conditions is ... doesn't look like it matters that much. makes sense, the real initial condition is the relative difference of the population centers


```{r}
nsim <- 1000
plan(multisession)
sim <- settlements %>%
    prune(beta = 10, tolerance = .001) %N>%
  list(., ., .) %>%
  tibble(net = ., 
         env_base = list( env$grf_01, env$grf_15, env$grf_50)) %>%
  mutate(net = map2(net, env_base, ~mutate(.x, food = .y, anomaly = 0)),
         sim = future_map(net, function(x) reduce(1:nsim, ~interact(.x), .init = x))) 
```








Below we see that, holding the distance deterrence parameters constant, the degree of spatial autocorrelation in the environment effects equilibrium territory size
```{r}
p1 <- sim[[1,3]] %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_01)) +
  geom_edge_link() +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
p2 <- sim[[2,3]] %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_15)) +
  geom_edge_link() +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
p3 <- sim[[3,3]] %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_50)) +
  geom_edge_link() +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
p1 + p2 + p3
```

changing the size of autocorrelation in the environment does not seem to change the territory size/ nd graph for food appreciably. What about at different  beta levels? these results are at 5 and 10, so try others?

```{r}
p4 <- sim[[1,3]] %>%
  nystuen_dacey() %>%
  mutate(group = group_components()) %>%
  as_tibble %>%
  bind_cols(env,.) %>%
  select(x, y, food, population, anomaly, group) %>%
  `st_precision<-`(10) %>%
  group_by(group) %>%
  summarise(food = sum(food), population = sum(population), geometry = st_union(geometry)) %>%
  ggplot() +
  geom_sf() +
  scale_fill_scico(palette = 'bamako')

p5 <- sim[[2,3]] %>%
  nystuen_dacey() %>%
  mutate(group = group_components()) %>%
  as_tibble %>%
  bind_cols(env,.) %>%
  select(x, y, food, population, anomaly, group) %>%
  `st_precision<-`(10) %>%
  group_by(group) %>%
  summarise(food = sum(food), population = sum(population), geometry = st_union(geometry)) %>%
  ggplot() +
  geom_sf(aes()) +
  scale_fill_scico(palette = 'bamako')

p6 <- sim[[3,3]] %>%
  nystuen_dacey() %>%
  mutate(group = group_components()) %>%
  as_tibble %>%
  bind_cols(env,.) %>%
  select(x, y, food, population, anomaly, group) %>%
  `st_precision<-`(10) %>%
  group_by(group) %>%
  summarise(food = sum(food), population = sum(population), geometry = st_union(geometry)) %>%
  ggplot() +
  geom_sf(aes()) +
  scale_fill_scico(palette = 'bamako')

p4 + p5 + p6
```


```{r}
sim[[1,3]] %E>%
  filter(trade_flow > 1) %>%
  arrange(trade_flow) %>%
  ggraph(x = x, y = y) +
  geom_edge_fan(aes(color = trade_flow), width = 1.2) +
  scale_size_area() +
 # geom_node_point(aes(size = population))+
  coord_equal() +
  scale_edge_color_viridis() +
  theme_void()

last(sim) 
sim%E>%
  filter(migrant_flow > 1) %>%
  arrange(migrant_flow) %>%
  ggraph(x = x, y = y) +
  geom_edge_link(aes(color = migrant_flow), width = 1.2) +
 # geom_node_point(aes(size = population))+
  coord_equal() +
  scale_edge_color_viridis() +
  theme_void()
```




We don't see ideal free distribution

There's not a clear relationship between size and local productivity. what about in the region?


The larger one's hinterland is, the higher the population. not suprising

```{r}
sim_dat %>%
  filter(time == max(time)) %>%
  ggplot(aes(harvest, immigrants)) +
  geom_point(alpha = .5)

sim_dat %>%
  filter(time == max(time)) %>%
  ggplot(aes(food, population)) +
  geom_point(alpha = .5)
```



## now add time
also thinking about running these experiments with just a single city
the problem is that cities die out early and don't have enough time 



```{r}
sim_dat <- sim %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time))
sim_dat %>%
  ggplot(aes(time, population, group = id)) +
  geom_line(alpha = .2) +
  theme_classic()

sim_dat %>%
  ggplot(aes(harvest, population, group = id, color = time)) +
  geom_path(alpha = .2) +
  scale_color_viridis_c() +
  theme_classic() +
  coord_fixed()

sim_dat %>%
  ggplot(aes(immigrants, population, group = id, color = time)) +
  scale_color_viridis_c() +
  geom_path(alpha = .2) +
  theme_classic() +
  coord_equal()
```

it looks like cities will form at equilibrium where environmental variability is the least. but this might depend on the rate of change?
```{r}
sim4 <- settlements %>%
      prune(beta = 10, tolerance = .001) %N>%
   mutate(food = env$grf_15,
          anomaly = env$oscillation) %>%
  accumulate(sin(1:1000 * .05), ~interact(.x, fluctuation = .y), .init = .)
```

so without scalking behavior you get the crazy initial growth but then it doesn't maintain. with scaling behavior it drops back off
```{r}
sim4 %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>% 
  ggplot(aes(time, (population), group = id)) +
  geom_line(alpha = .2) +
  theme_classic()
```

```{r}
sim4 %>%
  map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time= as.numeric(time)) %>% 
  ggplot(aes(food, population, group = id, color = id)) +
  geom_point(alpha = .2) +
  theme_classic()
```

```{r}
last(sim4) %>%
  nystuen_dacey() %>%
  ggraph(x = x, y = y) +
    geom_sf(data = env, aes(fill = grf_100)) +
  geom_edge_link(alpha = .5) +
  scale_size_area() +
  geom_node_point(aes(size = population))+
  coord_sf(datum = NA) +
  scale_fill_scico(palette = 'bamako') +
  theme_void()
```
```{r}
last(sim4) %>%
  nystuen_dacey() %>%
  mutate(group = group_components()) %>%
  as_tibble %>%
  bind_cols(env,.) %>%
  select(x, y, food, population, anomaly, group) %>%
  `st_precision<-`(10) %>%
  group_by(group) %>%
  summarise(food = sum(food), population = sum(population), geometry = st_union(geometry)) %>%
  ggplot() +
  geom_sf(aes(fill = population)) +
  scale_fill_scico(palette = 'bamako')
```

```{r}
anim <- sim4 %>%
#   map(nystuen_dacey) %>%
   map(as_tibble, 'nodes') %>%
  bind_rows(.id = 'time') %>%
  mutate(time = as.numeric(time)) %>%
  filter(between(time, 1, 500)) %>%
 filter(time %% 5 == 0) %>%
ggplot() +
  #  geom_sf(data = env, aes(fill = grf_100)) +
  geom_point(aes(x, y, size = population))+#aes(color = terminal)) +
  #coord_sf(datum = NA) +
  coord_equal() +
  #scale_fill_scico(palette = 'bamako')
  theme_void() +
  labs(title = 'Year: {closest_state}') +
  transition_states(time)

animate(anim, nframes = 199)
```

It matters less if you're on productive land, more if you have access to productive land no one else does

Here are two sample references: @Feynman1963118 [@Dirac1953888].


# Discussion
constant migration rate

discuss in light of anderies and hegmon 2011 specificaly

the importance of terriotiality and comeption for access to agricultural land

importance of the onset timing onset of the variability regime relative to other stuff

even fluctuation may not be realistic, translate through crop model

Edge effects -- different ways of handling them. Sidestepped here by the shear size of the domain. hexagons have low perimeter to area ratio

different functional forms for distance decay

Next, allow climate variability to influence resource dynamics. Assume a water-limited environment, so that the growth rate and carrying capacity of the resource represents the limitation of soil moisture on resource growth and abundance. The static parameters $r$ and $K$ are replaced with an unknown function $f\left(X_i, Q_i\right)$, representing logistic growth dependant on soil moisture $Q$ -- such functions are common in ecology \parencite[e.g., see][]{Ursino2007ModelingProcesses} but are kept generic here to enable application in variable ecohydrological contexts. As with $\mathbf{H}$ and $\mathbf{E}$ above, $Q$ can be replaced by an $I \times I$ adjacency matrix $\mathbf{Q}$, representing the pairwise directed moisture fluxes between all $X_i$ resource systems. This moisture-recycling network can be generated synthetically by the modeler, to explore different environmental scenarios, or estimated empirically from gridded observations, climate model outputs, or paleo-reanalysis data.

Empirical estimates of $\mathbf{Q}$ can be derived using functional network analysis, a method for inferring latent connectivity by comparing time series measured at every element of a complex system [@Donges2015UnifiedPackage]. The elements of an empirical $\mathbf{Q}$ correspond to the \textit{transfer entropy} between time series of precipitation minus evapotranspiration (i.e. the land-atmosphere moisture flux) at each grid cell of a climate model. Transfer entropy is an information-theoretic measure analogous to standard measures of correlation, but extended to capture causal dependencies between nonlinear time series [@Runge2012EscapingEntropy]. As such, a functional network representation of climate variability is conceptually and mathematically similar to the empirical orthogonal functions used in the American Southwest case but allows for more direct representations of the circulation dynamics leading to those patterns [@Donges2015]. 

Why hexagons (birch et al 2007). Edge effects of the whole hexagonal domainare slo decreased

# Conclusion


# References {#references .unnumbered}

```{r}
knitr::knit_exit()
```


Experimenting with gdistance
```{r}
env <- matrix(1, nrow = 100, ncol = 100) %>% 
  raster(xmx = 100, ymx = 100)

euc_dist <- function(x1, x2, y1, y2){
  sqrt((x1 - x2) ^ 2 + (y1 - y2) ^2)
}

trans <- transition(env, transitionFunction = mean, directions = 8) %>%
  geoCorrection(type = 'r')

set.seed(1000)
settlements <- tbl_graph(edges = expand.grid(from = 1:n, to = 1:n),
                 nodes = tibble(population = pop_start,
                                attractiveness = 1,
                                x = sample(1:100, n, replace = TRUE),
                                y = sample(1:100, n, replace = TRUE))) %E>%
  mutate(euclidean = euc_dist(.N()$x[from], .N()$x[to], 
                             .N()$y[from], .N()$y[to])) %>%
  filter(!edge_is_loop())

sites <- settlements %N>%
  as_tibble() %>%
  select(x:y) %>%
  as.matrix

accCost(trans, sites) %>% plot

routes <- commuteDistance(trans, sites) %>%
  as.matrix %>%
  as_tbl_graph %E>%
  as_tibble %>%
  left_join(settlements, .) 


routes %>%
  as_tibble() %>%
  ggplot(aes(euclidean, weight)) + geom_point()

passage(trans, sites[2,], sites[1,], theta=5) %>% plot

plan(multicore, workers = 3)

paths <- routes %E>%
  as_tibble %>%
  filter(from > to) %>%
  mutate(passage = future_map2(from, to, ~passage(trans, sites[.x, ], sites[.y,], theta = 15)))

t1 <- paths %>% pull(passage) %>% brick %>% sum
plot(t1 / 300)

1:20 %>% accumulate(~.*(log(2) + 1), .init = t1) %>% .[[20]] %>% plot

feedback <- function(x) 

paths <- settlements %E>%
  group_by(from) %>% 
  top_n(-6, distance) %>%
  ungroup %N>%
  igraph::as.undirected(mode = 'collapse', edge.attr.comb = 'first') %>%
  as_tbl_graph
```


# getting rid of edge effects
```{r}
tst <- pts
tst[,2] <- tst[,2] + max(pts[,2]) - min(pts[,2]) * .5
tst[,1] <- tst[,1] + min(pts[,1])
plot(rbind(pts, tst))

min(pts[,1])
max(pts[,2])
```

# harris wilson spatial interaction model
```{r interact}
interact <- function(net, alpha = 1.05, beta = 0.2){
  net %E>%
    mutate(utility = .N()$attractiveness[to] ^ alpha * exp(-beta * effective_distance))  %N>%
    mutate(outflow = population / centrality_degree(weights = utility,
                                                    mode = 'out', loops = FALSE)) %E>%
    mutate(flow = .N()$outflow[from] * utility) %>%
    select(-utility) %N>%
    select(-outflow)
  }

grow <- function(net, k = 1, epsilon = 0.1, G = 0.1){
  net %N>%
    mutate(inflow = centrality_degree(weights = flow, mode = 'in', loops = FALSE),
           inflow = if_else(edge == TRUE, inflow + inflow * G, inflow),
           attractiveness = attractiveness + epsilon * (inflow - k * attractiveness),
           population = n * pop_start * attractiveness / sum(attractiveness)) %>%
    select(-inflow)
}

# k convert units of flow to units of attractiveness. should be 1? we're interpreting units of flow as people, so probably not.... maybe we can say that a 1 of the climate variable is the amount of rain to produce enough food to feed xx people, and rescale from there?
```

# run sim code
need to figure out how to split the ... up to go to both sides. maybe define teh ~interact(...) outside of the accumulate commands?


```{r message = FALSE}
run_sim <- function(init, nsim = 1000, keep_intermediate = FALSE, ...){
  if(keep_intermediate == TRUE){
    sim <- accumulate(1:nsim, ~interact(.x, ...), .init = init) %>%
      map(as_tibble, 'nodes') %>%
      bind_rows(.id = 'time') %>%
      mutate(time = as.numeric(time)) # remove the initial state
  } else{
    sim <- reduce(1:nsim, ~interact(.x, ...), .init = settlements)
  }

  return(sim)
}
```

### hex sticker for silvanus!
```{r}
 paths %>%
  mutate(grf_100 = make_grf(x, y, 100)) %>%
  as_tibble %>%
  select(grf_100) %>%
  bind_cols(hex,.) %>%
  ggplot() +
  geom_sf(aes(fill = value), lwd = .1) +
  theme_void() +
  scale_fill_scico(palette = 'oleron') +
  coord_sf(datum = NA)
```


## maintian

double check that trade flow to home regions is kept by maintain, looks like it nas out rn
```{r}
get_distance <- function(net){
  node_data <- as_tibble(net, 'nodes')
  dist_weights <- as_tibble(net, 'edges')$distance

  net %>%
    igraph::distances(weights = dist_weights) %>% # needs weight column
    replace(. == 0, 999) %>% # replace 0 values with 999 temporarily
    as_tbl_graph(directed = TRUE) %>%
    mutate(!!!node_data) %E>%
    mutate(weight = if_else(weight == 999, phi, weight)) %>%
    rename(distance = weight)
}

maintain <- function(routes, paths, a, b){
  pop <- routes %N>% pull(population)

  tmp1 <- as_tibble(routes, 'edges') %>%
    group_by(from) %>%
      nest %>%
    mutate(path = map(from, get_paths, net = paths)) %>%
    select(from, path) %>%
    unnest(cols = c(path)) %>%
    mutate(to = rep(1:n, times = n)) %>% 
    left_join(as_tibble(routes, 'edges'), .) %>%
    mutate(len = map_dbl(path, length))
  
  tmp2 <- tibble(path =  unlist(tmp1$path),
           migrant_flow = rep(tmp1$migrant_flow, times = tmp1$len),
           trade_flow = rep(tmp1$trade_flow, times = tmp1$len)) %>%
        group_by(path) %>%
        summarise(trade_flow = sum(trade_flow),
                  migrant_flow = sum(migrant_flow))

  paths %E>%
    select(-traffic) %>%
    left_join(tmp2, by = c('.tidygraph_edge_index' = 'path')) %N>%
  # mutate(total_traffic = traffic + total_traffic,
   #        effective_distance = distance * improve_path(total_traffic, a = a, b = b)) %N>%
    mutate(population = pop)
}

get_paths <- function(from, net){
    
  dist_weights <- paths %E>%
    as_tibble %>%
    pull(effective_distance)
  
  shortest_paths(net, from, weights = dist_weights, output = 'epath') %>%
    .$epath %>% 
    map(as.numeric)
}

improve_path <- function(traffic, a, b){
  (1 - a) * exp(-b * traffic) + a
}
```
